{"meta":{"title":"张卫的博客","subtitle":"Done is better than perfect","description":null,"author":"张卫","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-07-18T07:18:33.000Z","updated":"2021-03-03T14:33:17.603Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"学习之地"},{"title":"分类","date":"2019-11-24T10:04:14.000Z","updated":"2021-03-03T14:33:17.604Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-24T06:58:16.000Z","updated":"2021-03-03T14:33:17.623Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Unity协程","slug":"Unity/Unity协程","date":"2021-03-17T04:13:25.000Z","updated":"2021-03-17T14:42:17.465Z","comments":true,"path":"2021/03/17/Unity/Unity协程/","link":"","permalink":"http://yoursite.com/2021/03/17/Unity/Unity%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"为什么要使用协程 协程就是一个伪线程， # 如何使用协程 # 协程实现原理 # 参考 IEnumerable VS IEnumerator in C#","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"协程","slug":"协程","permalink":"http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"委托与事件","slug":"编程语言/CSharp/委托与事件","date":"2021-03-14T10:16:09.000Z","updated":"2021-03-17T15:45:16.997Z","comments":true,"path":"2021/03/14/编程语言/CSharp/委托与事件/","link":"","permalink":"http://yoursite.com/2021/03/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/","excerpt":"委托 什么是委托？委托与事件有什么关系呢？先来看一下委托的定义，代码如下： 12345678910111213namespace DotnetExample&#123; //定义一个委托 public delegate void VoidCallback(); // Console必须要一个Main函数才能编译通过 class Program &#123; static void Main(string[] args) &#123; &#125; &#125;&#125;","text":"委托 什么是委托？委托与事件有什么关系呢？先来看一下委托的定义，代码如下： 12345678910111213namespace DotnetExample&#123; //定义一个委托 public delegate void VoidCallback(); // Console必须要一个Main函数才能编译通过 class Program &#123; static void Main(string[] args) &#123; &#125; &#125;&#125; 这样的就定义了一个返回值和参数都为空的委托，这个委托究竟是什么呢，先别急，我来看哈，这个委托转换成CIL是什么样的，CIL代码如下： 123456789101112131415.class public auto ansi sealed DotnetExample.VoidCallback extends [System.Runtime]System.MulticastDelegate&#123; .method public hidebysig specialname rtspecialname instance default void .ctor([System.Runtime]System.Object 'object', native int 'method') runtime managed &#123; &#125; // End of method System.Void DotnetExample.VoidCallback::.ctor(System.Object,System.IntPtr) .method public hidebysig newslot virtual instance default void Invoke() runtime managed &#123; &#125; // End of method System.Void DotnetExample.VoidCallback::Invoke() .method public hidebysig newslot virtual instance default [System.Runtime]System.IAsyncResult BeginInvoke(class [System.Runtime]System.AsyncCallback callback, [System.Runtime]System.Object 'object') runtime managed &#123; &#125; // End of method System.IAsyncResult DotnetExample.VoidCallback::BeginInvoke(System.AsyncCallback,System.Object) .method public hidebysig newslot virtual instance default void EndInvoke(class [System.Runtime]System.IAsyncResult result) runtime managed &#123; &#125; // End of method System.Void DotnetExample.VoidCallback::EndInvoke(System.IAsyncResult)&#125; // End of class DotnetExample.VoidCallback 现在我们明白了原来委托就是一个继承至System.MulticastDelegate的类，delegate关键字就是一个语法糖而已。MulticastDelegate类又继承至Delegate。看看Delegate都有哪些内容，如下图： 其中重要的几个函数： 构造函数 .ctor(Type, String), .ctor(Object String)，当更一个委托赋值(=)时，会根据方法类型选择调用哪个构造函数，静态的函数调用第一种形式的构造函数，如果是成员函数的则会调用第二种形式的构造函数 Combine函数， 当使用+=的时候则会调动Combine将一个委托追加到调用链的后面。 CreateDelegate静态函数，更具各种类型创建委托 GetInvocationList函数，获取委托链上的说有委托 Remove函数，当使用-=的时候回调用Remove函数，它跟Combine函数是一对的，一个负责添加委托，一个负责移除委托。 上面定义了一个VoidCallback委托，下面我们来使用一下这个委托，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738namespace DotnetExample&#123; class Program &#123; static void Main(string[] args) &#123; new DelegateExample().Init(); &#125; &#125; public delegate void VoidCallback(); class DelegateExample &#123; public VoidCallback voidCallback; public void Init() &#123; voidCallback = TestCallback; voidCallback += TestStaticCallback; voidCallback.Invoke(); voidCallback -= TestCallback; voidCallback -= TestStaticCallback; &#125; void TestCallback() &#123; Console.WriteLine(\"TestCallback is called.\"); &#125; static void TestStaticCallback() &#123; Console.WriteLine(\"TestStaticCallback is called.\"); &#125; &#125;&#125; 上面这些函数都是Delegate类里面的功能函数，其中“=”运算换转换成构造函数，“+=”会转换成Combine函数，“-=”会被转换成Remove函数。那么Invoke函数是哪里来的呢？在上面我们定义了一个委托，编译后给我们生成了一个类，这个类里面包含了3个函数其中一个就是Invoke,还是两个是BeginInvoke和EndInvoke函数，这几个函数有什么区别呢？Invoke是同步函数在主线程执行而BeginInvoke和EndInvoke是用于异步调用的一对函数在其他线程运行。BeginInvoke和EndInvoke如何使用,可以参考https://www.cnblogs.com/canger/p/5938591.html。 事件 我们还是通过CIL来了解事件吧！先定义个事件看看转换后的CIL代码是什么样的，事件定义代码如下： 12345678910111213namespace DotnetExample&#123; public delegate void VoidCallback(); class Program &#123; public static event VoidCallback eventFields; static void Main(string[] args) &#123; &#125; &#125;&#125; 删除了无关代码后，IL代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.class private auto ansi beforefieldinit DotnetExample.Program extends [System.Runtime]System.Object&#123; // eventFields这个字段被转换成里private的访问权限 .field private static class DotnetExample.VoidCallback eventFields // 生成了一个add_xxxx(字段名)的函数 .method public hidebysig specialname static default void add_eventFields(class DotnetExample.VoidCallback 'value') cil managed &#123; // Method begins at Relative Virtual Address (RVA) 0x2050 // Code size 39 (0x27) .maxstack 3 .locals init(class DotnetExample.VoidCallback V_0, class DotnetExample.VoidCallback V_1, class DotnetExample.VoidCallback V_2) IL_0000: ldsfld class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_0005: stloc.0 IL_0006: ldloc.0 IL_0007: stloc.1 IL_0008: ldloc.1 IL_0009: ldarg.0 IL_000a: call [System.Runtime]System.Delegate class [System.Runtime]System.Delegate::Combine([System.Runtime]System.Delegate, [System.Runtime]System.Delegate) IL_000f: castclass class DotnetExample.VoidCallback IL_0014: stloc.2 IL_0015: ldsflda class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_001a: ldloc.2 IL_001b: ldloc.1 IL_001c: call !!0 class [System.Threading]System.Threading.Interlocked::CompareExchange&lt;class DotnetExample.VoidCallback&gt;(!!0&amp;, !!0, !!0) IL_0021: stloc.0 IL_0022: ldloc.0 IL_0023: ldloc.1 IL_0024: bne.un.s IL_0006 IL_0026: ret &#125; // End of method System.Void DotnetExample.Program::add_eventFields(DotnetExample.VoidCallback) // 生成了一个remove_xxxx(字段名)的函数 .method public hidebysig specialname static default void remove_eventFields(class DotnetExample.VoidCallback 'value') cil managed &#123; // Method begins at Relative Virtual Address (RVA) 0x2084 // Code size 39 (0x27) .maxstack 3 .locals init(class DotnetExample.VoidCallback V_0, class DotnetExample.VoidCallback V_1, class DotnetExample.VoidCallback V_2) IL_0000: ldsfld class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_0005: stloc.0 IL_0006: ldloc.0 IL_0007: stloc.1 IL_0008: ldloc.1 IL_0009: ldarg.0 IL_000a: call [System.Runtime]System.Delegate class [System.Runtime]System.Delegate::Remove([System.Runtime]System.Delegate, [System.Runtime]System.Delegate) IL_000f: castclass class DotnetExample.VoidCallback IL_0014: stloc.2 IL_0015: ldsflda class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_001a: ldloc.2 IL_001b: ldloc.1 IL_001c: call !!0 class [System.Threading]System.Threading.Interlocked::CompareExchange&lt;class DotnetExample.VoidCallback&gt;(!!0&amp;, !!0, !!0) IL_0021: stloc.0 IL_0022: ldloc.0 IL_0023: ldloc.1 IL_0024: bne.un.s IL_0006 IL_0026: ret &#125; // End of method System.Void DotnetExample.Program::remove_eventFields(DotnetExample.VoidCallback) // eventFields事件定义了+= addon 和-= removeon两个函数 .event class DotnetExample.VoidCallback eventFields &#123; .addon default void DotnetExample.Program::add_eventFields (class DotnetExample.VoidCallback 'value') .removeon default void DotnetExample.Program::remove_eventFields (class DotnetExample.VoidCallback 'value') &#125; // End of property DotnetExample.VoidCallback DotnetExample.Program::eventFields&#125; // End of class DotnetExample.Program 根据IL代码发现，我们定义的public的事件字段eventFields被转换成了private的访问权限，并且eventFields也就是只是委托类型的对象，还生成了两个public的函数add_xxxx和remove_xxxx函数，add_xxxx函数里直接调用了委托的Combine函数，remove_xxxx函数了调用了委托的Remove函数，以及一个event类型，里面包含了两个函数分别对应+=和-=两个运算符。 委托与事件的区别 根据上两节的分析，总结委托与事件的区别。 相同点 事件本质也是委托 不同点 事件访问权限都是private的，要触发事件调用只能在类的内部。 在外部，事件只能通过+=或-=进行回调函数的添加或删除","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"聊聊.Net开发平台","slug":"编程语言/CSharp/聊聊.Net开发平台","date":"2021-03-04T09:30:21.000Z","updated":"2021-03-17T15:42:10.814Z","comments":true,"path":"2021/03/04/编程语言/CSharp/聊聊.Net开发平台/","link":"","permalink":"http://yoursite.com/2021/03/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/%E8%81%8A%E8%81%8A.Net%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/","excerpt":"介绍 .Net是什么呢？.Net是1998年微软剑桥研究院的技术人员研究的下一代开发技术，并将其制定的规范(CLI)提交到了ECMA，形成了ECMA335规范, 随后被ISO采纳为国际标准ISO/IEC 23271:2012。到2002微软正式发布了.NET Framework 1.0。.NET Framework是.Net开发技术规范的第一个实现，所以在初期.Net和.Net Framework指的是同一个东西，但它们本质上是完全不同的。由于当时只有微软的.Net Framework实现了.Net标准所以也仅限于Windows开发栈。.Net Framework平台的内容包含很多组件和库，像WinForm, WebForm, WPF，Asp.net等。直到2004年Mono让其可以在Linux上运行了，慢慢的Mono也开始支持Android, iOS，MacOSx让.Net实现跨平台。","text":"介绍 .Net是什么呢？.Net是1998年微软剑桥研究院的技术人员研究的下一代开发技术，并将其制定的规范(CLI)提交到了ECMA，形成了ECMA335规范, 随后被ISO采纳为国际标准ISO/IEC 23271:2012。到2002微软正式发布了.NET Framework 1.0。.NET Framework是.Net开发技术规范的第一个实现，所以在初期.Net和.Net Framework指的是同一个东西，但它们本质上是完全不同的。由于当时只有微软的.Net Framework实现了.Net标准所以也仅限于Windows开发栈。.Net Framework平台的内容包含很多组件和库，像WinForm, WebForm, WPF，Asp.net等。直到2004年Mono让其可以在Linux上运行了，慢慢的Mono也开始支持Android, iOS，MacOSx让.Net实现跨平台。微软为了让.Net能够在多个平台上运行，在2014公布了.Net Core计划，并于2016年发布了第一个.Net开源版本.Net Core1.0该版本主要实现了Asp.net, 后陆续加入了WinForm和WPF的支持（仅在Windows平台下），意在将.Net Framework的功能移植成开源跨平台的版本，当然.Net Core 也是.Net的未来。为了快速的整合.Net的生态，微软在2016年收购了Xamarin（Mono）, 并将Xamarin的开发工具集整合到了Vistual Studio中，至此微软统一了.Net生态。\b\b废话说完，下面进入正题。聊一聊.Net中的相关概念和术语，相信大家也经见过一些，比如：CLI、CIL、CTS、CLS、CLR、JIT、BCL、FCL、Module、Assembly 等，本文不会安字典顺序来一一讲解，因为这样大家很难理解也很难记住，本文将通过大家熟悉的HelloWorld程序(基于.Net Core 5.0)来进行解释，欢迎主角登场！ HelloWorld粉墨登场 本文实例基于 .Net core 5.0运行，我们先来创建一个控制台工程命名为HelloWorld，命令如下： 1dotnet new console -o ./HelloWorld 创建完成后将创建如下目录结构，如下图： dotnet初始项目结构 HelloWorld.csproj 项目文件 Program.cs 默认入口代码Main函数 obj 临时文件 至此HelloWorld程序就完成了，代码如下： 12345678910111213// Program.csusing System;namespace HelloWorld&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); &#125; &#125;&#125; 这个代码虽然简单，就在控制台打印了一个“Hello World!”. 那这个Hello World有什么怎么被打印出来的呢？里面的Console.WriteLine有哪里来的呢？这个代码编译后会什么内容呢？会和C/C++编译出来的东西一样吗？这个代码又是如何运行起来的呢？这里面就要涉及到.Net规范的核心内容了，下面我们就通过这个Hello World程序来进行介绍。 在HelloWorld目录里，运行如下命令将HelloWorld程序编译出来，命令如下： 1dotnet build -c \"Release\" 编译后将生产一个HelloWorld.dll的文件, 此文件就是一个程序集(Assembly)。那么这个程序集的结构是什么样的呢？ Assembly Assembly包含了哪些内容呢？Assembly是一个自诉型程序集，主要有下面2类 Manifest 清单部分描述了Assembly自身的一些基础信息，包括版本信息，\b以及对模块和其他程序集的引用关系等；Assembly至少包含一个Module，Module又是代码(CIL)的集合。 元数据 元数据描述了程序集拥有哪些类型，类型的成员，以及成员的可见性等。 CIL代码，详细信息参见下一节 我们可以通过安装ILDASM工具来查看Assembly里的信息，命令如下： 安装 1dotnet tool install -g dotnet-ildasm 查看程序集 1dotnet ildasm HelloWorld.dll -o ./HelloWorld.il 我们先目睹一下HelloWorld Assembly里的Manifest信息： 12345678910111213141516171819202122232425262728293031323334.assembly extern System.Runtime&#123; .publickeytoken &#x3D; ( B0 3F 5F 7F 11 D5 0A 3A ) &#x2F;&#x2F; .._..... .ver 5:0:0:0&#125;.assembly extern System.Console&#123; .publickeytoken &#x3D; ( B0 3F 5F 7F 11 D5 0A 3A ) &#x2F;&#x2F; .._..... .ver 5:0:0:0&#125;.assembly &#39;HelloWorld&#39;&#123; .custom instance void class [System.Runtime]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) &#x3D; ( 01 00 08 00 00 00 00 00 ) &#x2F;&#x2F; ........ .custom instance void class [System.Runtime]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() &#x3D; ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78 63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 ) &#x2F;&#x2F; ....T..WrapNonExceptionThrows. .custom instance void class [System.Runtime]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) &#x3D; ( 01 00 18 2E 4E 45 54 43 6F 72 65 41 70 70 2C 56 65 72 73 69 6F 6E 3D 76 35 2E 30 01 00 54 0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C 61 79 4E 61 6D 65 00 ) &#x2F;&#x2F; ....NETCoreApp.Version.v5.0..T..FrameworkDisplayName. .custom instance void class [System.Runtime]System.Reflection.AssemblyCompanyAttribute::.ctor(string) &#x3D; ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 ) &#x2F;&#x2F; ...HelloWorld.. .custom instance void class [System.Runtime]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) &#x3D; ( 01 00 07 72 65 6C 65 61 73 65 00 00 ) &#x2F;&#x2F; ...release.. .custom instance void class [System.Runtime]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) &#x3D; ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 ) &#x2F;&#x2F; ...1.0.0.0.. .custom instance void class [System.Runtime]System.Reflection.AssemblyInformationalVersionAttribute::.ctor(string) &#x3D; ( 01 00 05 31 2E 30 2E 30 00 00 ) &#x2F;&#x2F; ...1.0.0.. .custom instance void class [System.Runtime]System.Reflection.AssemblyProductAttribute::.ctor(string) &#x3D; ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 ) &#x2F;&#x2F; ...HelloWorld.. .custom instance void class [System.Runtime]System.Reflection.AssemblyTitleAttribute::.ctor(string) &#x3D; ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 ) &#x2F;&#x2F; ...HelloWorld.. .hash algorithm 0x00008004 .ver 1:0:0:0&#125;.module &#39;HelloWorld.dll&#39;&#x2F;&#x2F; MVID: &#123;70604f0b-74ab-4028-87d6-2026571d0897&#125;.imagebase 0x00400000.file alignment 0x00000200.stackreserve 0x00100000.subsystem 0x0003 &#x2F;&#x2F; WindowsCui.corflags 0x00000001 &#x2F;&#x2F; ILOnly CIL——公共中间语言 C#编译器将C#代码编译成包含了CIL的程序集(Assembly),其他的编程语言比如VB,F#等,通过自己的编译器将源码编译成CIL，那些能够被编译成CIL的编程语言我们统称为面向.Net的语言，正因为有CIL中间语言的存在才使得.Net能够实现跨语言编程。 接下来我们看哈上面的C#的HelloWorld程序的CIL代码，如下： 12345678910111213141516171819202122.class private auto ansi beforefieldinit HelloWorld.Program extends [System.Runtime]System.Object&#123; .method private hidebysig static default void Main(string[] args) cil managed &#123; &#x2F;&#x2F; Method begins at Relative Virtual Address (RVA) 0x2050 .entrypoint &#x2F;&#x2F; Code size 11 (0xB) .maxstack 8 IL_0000: ldstr &quot;Hello World!&quot; IL_0005: call void class [System.Console]System.Console::WriteLine(string) IL_000a: ret &#125; &#x2F;&#x2F; End of method System.Void HelloWorld.Program::Main(System.String[]) .method public hidebysig specialname rtspecialname instance default void .ctor() cil managed &#123; &#x2F;&#x2F; Method begins at Relative Virtual Address (RVA) 0x205C &#x2F;&#x2F; Code size 7 (0x7) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void class [System.Runtime]System.Object::.ctor() IL_0006: ret &#125; &#x2F;&#x2F; End of method System.Void HelloWorld.Program::.ctor()&#125; &#x2F;&#x2F; End of class HelloWorld.Program 下面我们来分析一下“公共中间语言”的“公共”，“中间”和“语言”都代表的什么 ### 公共 公共指的是通用的意思，也就是说不论你用哪种语言编写的代码最终编译出的都是通过CIL来描述的，我们新建一个VB的HelloWorld工程，命令如下： 1dotnet new console -lang VB -o ./HelloWorldVB VB代码如下： 1234567Imports SystemModule Program Sub Main(args As String()) Console.WriteLine(\"Hello World!\") End SubEnd Module 编译后将HelloWorldVB.dll通过ildasm工具反编译成CIL,代码如下： 123456789101112131415.class private auto ansi sealed HelloWorldVB.Program extends [System.Runtime]System.Object&#123; .custom instance void class [Microsoft.VisualBasic.Core]Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute::.ctor() &#x3D; ( 01 00 00 00 ) &#x2F;&#x2F; .... .method public static default void Main(string[] args) cil managed &#123; .custom instance void class [System.Runtime]System.STAThreadAttribute::.ctor() &#x3D; ( 01 00 00 00 ) &#x2F;&#x2F; .... &#x2F;&#x2F; Method begins at Relative Virtual Address (RVA) 0x2050 .entrypoint &#x2F;&#x2F; Code size 11 (0xB) .maxstack 8 IL_0000: ldstr &quot;Hello World!&quot; IL_0005: call void class [System.Console]System.Console::WriteLine(string) IL_000a: ret &#125; &#x2F;&#x2F; End of method System.Void HelloWorldVB.Program::Main(System.String[])&#125; &#x2F;&#x2F; End of class HelloWorldVB.Program 可以看出C#和VB编译出来的CIL代码基本上一样只是C#多生成了一个类的构造函数。因为VB是面向过程的编程所以不存在类和类的构造函数这一说。现在我们应该明白公共代表什么意思了吧！ 中间 为什么是“中间”呢？CIL不像C/C++静态语言会直接编译链接成CPU能够直接执行的机器码，而是需要一个公共语言运行时(CLR)来进行及时的编译（JIT）。所以将其称为中间语言。JIT编译器的根据执行编译阶段大致可以分为3类： 1. Pre-JIT 编译器，在程序集部署时进行编译，就是通过一个Ngen.exe(本地代码生成器)将CIL转换为本地机器码。 2. Normal JIT 编译器，在程序集首次调用的时候将其编译成本地机器码并缓存。 3. Econo JIT 编译器，在方法执行前进行编译，执行完后删除，dotnet2.0后就使用的此类型的JIT 语言 CIL其实本身也是一门基于堆栈的编程语言，只是相比C#要稍微低级（并不是很low的意思）一些，我们也可以直接写CIL代码然后使用ILASM工具将其转换成程序集在CLR中运行。 我们在回头看看HelloWorld程序，里面调用了一个Console.WriteLine函数，那这个函数又是哪里来的呢？ BCL和FCL BCL-基础类库 我们在开发一个程序时，不可能任何基础功能都功能都从零开始，所以各个.Net的实现平台都为我们定义一个基础功能类库BCL, 比如像组数，链表，字典, Console,包括基本原类型byte，short, long这这些都是基于System下的System.Byte,System.Int16和System.Int64,当然还包含了先系统相关的功能比如线程,安全性等。但是各个平台的对这些接口的实现也有所差异，所以为了实现各个平台的通用性，微软在自家产品中率先制定了一个可移植类库PCL，取各个平台的公用部分形成，结构如下图： 随着实现.Net平台的增多，为了更好跨平台性微软制定了基础库的标准.Net Standard，所有.Net实现平台上的BCL接口都必须遵守.Net Standard中制定的标准，这样便可以让在各个平台开发时调用的基础库的接口都是统一的。虽然BCL构成了我们编程的基础库，但是比如我们要开发一个Windows的应用，那么界面该如何搭建呢，界面上又有哪些控件呢？接下来就要介绍框架类库-FCL了。FCL和.Net Standard关系图如下： FCL-框架类库 BCL只是框架类库的一个子集而已，FCL包含的功能巨多，也是我们经常使用的类库，每个FCL的子库都够写一本书的了，我们更具功能可以将FCL大致分为一下3层。 - 最内一层，由BCL的大部分组成，主要作用是对.NET框架，.NET运行时及CIL语言本身进行支持，例如基元类型、集合类型、线程处理、应用程序域、运行时、安全性、互操作等。 - 中间一层，包含了对操作系统功能的封装，例如文件系统、网络连接、图形图像、XML操作等。 - 最外一层，包含各种类型的应用程序，例如Windows Forms、Asp.NET、WPF等。 CTS-公共类型系统 如果我们要开发一门像C#或VB一样的语言，在编译后也生成CIL语言，在.Net环境中运行，那么我们这个语言具有哪些特性就不是我们语言所能决定的了，而是有CIL所定义的规则决定的，而这些定义的规则就是CTS,CTS中定义了类，接口，结构体也定义了类里能包含属性，字段，函数，事件等，也定义了类只能继承一个父类，可以实现多个接口。C#和VB就是微软定义的符合CTS规则的语言。 CLS-公共语言规范 假设我们有3门面向.Net的语言，如果3门语言公开（Public）部分需要相互调用,那么他们必定需要遵循一定规则，这个规则就是CLS,CLS是CTS的一个子集，各个面向.Net的语言需要准守这个规范，否则就不就会存在互调的兼容性问题。CLS具体有哪些规则呢？是否区分大小写，标识符的命名规则如何，可以使用的基本类型有哪些，构造函数的调用方式（是否会调用基类构造函数），支持的访问修饰符等。 CLR-公共语言运行时 前面我们了解了.Net SDK编译出来的程序集（Assembly）的相关信息，下面我们将接着讨论，编程出来的程序集是怎么运行起来的呢？这就的归功于CLR，CLR其实就是一个能够执行CIL的虚拟机，其主要功能包括：管理应用程序域、加载和运行程序集、安全检查、JIT(将CIL代码即时编译为机器代码)、异常处理、对象析构和垃圾回收等。现在我们了解了CLR的功能，但是还是不知道它是怎么运行起来的。要说清楚这个问题我们不必须先看看在系统中可执行文件的格式，在MacOs中是Mach-O格式，在Windows中是PE/COFF格式，在Linux是ELF格式，我们详细看下Mach-O文件吧，其他的格式都大同小异。Mach-O格式如下： Mach-O 的组成结构如图所示包括了： Header 包含该二进制文件的一般信息 字节顺序、架构类型、加载指令的数量等。 使得可以快速确认一些信息，比如当前文件用于 32 位还是 64 位，对应的处理器是什么、文件类型是什么 Load commands 一张包含很多内容的表 内容包括区域的位置、符号表、动态符号表等。 Data 通常是对象文件中最大的部分 包含 Segement 的具体数据 每个段的具体信息可以通过otool工具进行查看。\b 系统运行Mach-O文件大致步骤： 1. 系统把Mach-O文件加载进入内存， 2. 检查头看是否是相同CPU架构是否和符合当前的系统需求 3. 链接动态库 4. 找到入口程序(Main函数)的地址开始执行 我们发布一下HelloWorld程序，代码如下： 1dotnet publish -r osx-x64 -c Release --self-contained 我们通过自包含的方式发布，这样就不需要目标机器上安装.Net运行时了。我们来看一下发布后的文件有哪些,如下图： 重点是HelloWorld文件，这个文件是启动文件，这是一个Mach-O格式的文件，就想普通的MacOs系统的可以执行文件一样，他会链接像libclrjit.dylib,libcoreclr.dylib的CLR相关动态库文件，这样当HelloWorld通过系统调起的时候便会启动CLR, 并执行HelloWorld.dll中的主函数。我也可以直接使用dotnet HelloWorld.dll执行我们的程序集，因为dotnet这个Mach-o格式文件会去链接CLR相关的库。 总结 此篇文章主要讲了CLI规范中的相关术语，并通过一个HelloWorld的程序了解了一个CIL程序集时如何被编译生成的，也了解了一个程序集的内部结构，对.Net平台也有更深入的理解。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":".Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"在Hexo中使用Mathjax渲染数学公式","slug":"工具/Hexo/在Hexo中渲染MathJax数学公式","date":"2021-03-03T14:33:17.591Z","updated":"2021-03-03T14:33:17.591Z","comments":true,"path":"2021/03/03/工具/Hexo/在Hexo中渲染MathJax数学公式/","link":"","permalink":"http://yoursite.com/2021/03/03/%E5%B7%A5%E5%85%B7/Hexo/%E5%9C%A8Hexo%E4%B8%AD%E6%B8%B2%E6%9F%93MathJax%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","excerpt":"前言 Mathjax是一种支持在所有浏览器上显示数学公式的Javascript引擎，它支持绝大部分的Tex/LaTex语法，并且有三种输出HTML/CSS, SVG(矢量图)和MathML（Firefox支持的数公式标记语言）。本文主要介绍如何在将Mathjax整合进入Hexo中，在整合之前先介绍一下Tex/LaTex。","text":"前言 Mathjax是一种支持在所有浏览器上显示数学公式的Javascript引擎，它支持绝大部分的Tex/LaTex语法，并且有三种输出HTML/CSS, SVG(矢量图)和MathML（Firefox支持的数公式标记语言）。本文主要介绍如何在将Mathjax整合进入Hexo中，在整合之前先介绍一下Tex/LaTex。 Tex/LaTex介绍 TeX是由著名的计算机科学家Donald E. Knuth（高德纳）发明的宏语言排版系统，由于Tex是一种程序式的排版系统，对于一般用户来说很难上手，此时LaTex就应运而生了。 LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。由于本文的目的是为了在网页上显示数学公式，对于LaTeX的其他文档的排版不做介绍。先来看看LaTex实例，如下： 1234$a=\\begin&#123;bmatrix&#125;1&amp;2&amp;3\\end&#123;bmatrix&#125;$ %行向量$a=\\begin&#123;bmatrix&#125;1\\\\2\\\\3\\end&#123;bmatrix&#125;$ %列向量$a\\cdot b=\\sum_&#123;i=1&#125;^&#123;n&#125;a_ib_i$ %累加和 对应的渲染效果，如下： a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\) a=\\(\\begin{bmatrix}1\\\\2\\\\3\\end{bmatrix}\\) \\(a\\cdot b=\\sum_{i=1}^{n}a_ib_i\\) Hexo配置Mathjax 在Hexo配置Mathjax只需要5个步骤： 步骤1：卸载默认的渲染引擎hexo-renderer-marked 1npm uninstall hexo-renderer-marked --save 步骤2：安装新的渲染引擎hexo-renderer-pandoc 1npm install hexo-renderer-pandoc --save 步骤3：安装新渲染引擎依赖的第三方工具pandoc 直接进入pandoc的官方网站下载，地址:https://pandoc.org/installing.html 每个系统的安装方式不一样，根据自己的系统进行安装。 步骤4：修改Hexo的主题配置 本人使用的是next主题，在./themes/next/_config.yml文件中修改，如下： 步骤5：在需要支持Mathjax文章的头部添加mathjax标记,如下图： LaTex常用数学表达式语法 直接参见：超详细 LaTex数学公式 参考文献 [1] 网页上显示数学公式目前哪种方案最好？ [2] LaTeX排版系统 [3] LaTeX快速入门：一文浅谈TeX排版语法 [4] Latex基础语法 [5] Latex官网 [6] 超详细 LaTex数学公式","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"工具/Hexo","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Mathjax","slug":"Mathjax","permalink":"http://yoursite.com/tags/Mathjax/"}]},{"title":"Mecanim动画系统","slug":"Unity/Unity3D_Mecanim高级动画系统","date":"2020-07-27T12:20:58.000Z","updated":"2021-03-03T14:33:17.590Z","comments":true,"path":"2020/07/27/Unity/Unity3D_Mecanim高级动画系统/","link":"","permalink":"http://yoursite.com/2020/07/27/Unity/Unity3D_Mecanim%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"介绍 资源制作 资源导入 Animator状态机 Animator混合树 Animator分层 Animator遮罩 Animator IK 运动重定向","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"动画系统","slug":"动画系统","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"}]},{"title":"游戏介绍","slug":"游戏/游戏介绍","date":"2020-07-18T06:43:52.000Z","updated":"2021-03-03T14:33:17.602Z","comments":true,"path":"2020/07/18/游戏/游戏介绍/","link":"","permalink":"http://yoursite.com/2020/07/18/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"https://zhuanlan.zhihu.com/p/22745932 https://gameinstitute.qq.com/community/detail/101952","categories":[],"tags":[]},{"title":"安装CentOS 8","slug":"Linux/安装CentOS8","date":"2020-07-17T09:52:05.000Z","updated":"2021-03-03T14:33:17.590Z","comments":true,"path":"2020/07/17/Linux/安装CentOS8/","link":"","permalink":"http://yoursite.com/2020/07/17/Linux/%E5%AE%89%E8%A3%85CentOS8/","excerpt":"下载相关工具 下载CentOS8 系统镜像 官方下载地址：https://www.centos.org/download/，根据自己的情况选择下载什么镜像，阿里云和网易的镜像地址下载速度很快。本文下载的是CentOS-8.2.2004-x86_64最小化版，如果需要带GUI的系统可以下载完整版，各个版本的下载地址： 最小版本：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-minimal.iso 完整版：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-dvd1.iso","text":"下载相关工具 下载CentOS8 系统镜像 官方下载地址：https://www.centos.org/download/，根据自己的情况选择下载什么镜像，阿里云和网易的镜像地址下载速度很快。本文下载的是CentOS-8.2.2004-x86_64最小化版，如果需要带GUI的系统可以下载完整版，各个版本的下载地址： 最小版本：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-minimal.iso 完整版：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-dvd1.iso 下载制作U盘启动盘工具 官方检测刻入U盘无问题工具：Win32diskimager。 注意：使用win32diskimager准备一个新的U盘，写入系统盘之后是无法再添加其它数据，当写入成功之后，再次插入发现U盘不能显示的，若需要恢复可以参考这里 制作U盘启动盘 当下载了CentOS8镜像和安装了Win32diskimager工具后，我们就可以开始制作启动盘了。以下是具体步骤： 启动Win32diskimager 选择\b刚下载的CentOS8的镜像文件，注意在打开的“文件选择对话框”的文件过滤下拉框中选择显示所有的文件，默认是显示.IMG的文件 选择写入的盘，注意不要选错了。 点击“写入”按钮，等待写入完成 安装系统 当系统盘写入完成后，就可以选择你的电脑进行安装了，具体步骤如下： 1. 进入BIOS设置，将你刚写入了系统的U盘设置为第一启动盘 等待启动选择安装（白色为选中）,如下图： 跟着后续的步骤进行安装即可 配置网络 参见另一篇文章 Linux网络配置","categories":[],"tags":[]},{"title":"游戏AI介绍","slug":"游戏/AI/游戏AI介绍","date":"2020-07-11T10:22:45.000Z","updated":"2021-03-09T15:19:52.367Z","comments":true,"path":"2020/07/11/游戏/AI/游戏AI介绍/","link":"","permalink":"http://yoursite.com/2020/07/11/%E6%B8%B8%E6%88%8F/AI/%E6%B8%B8%E6%88%8FAI%E4%BB%8B%E7%BB%8D/","excerpt":"什么是游戏AI AI（artificial intelligence）即人工智能，游戏中的AI是让游戏里的对象具有一定的智能化，能够思考和决策，比如RPG游戏中的怪物知道有玩家攻击自己时进行反击，当玩家逃跑时会进行追击，当玩家远离自己时则放弃追击，这一系的决策和动作就是游戏中的AI要做的。和现下流行的人工智能不一样的是游戏里的AI还不能那么智能，不过现在已经在尝试将机器学习和游戏结合，让游戏对象更智能。\b 自治智能体 正如其命，有自治动作的智能体称之为“自治智能体”。在《看门狗》《GTA》里，街上走路的人群或者开动的汽车 就是一种自治智能体。主角开车如果冲向它们，这些自治智能体能够自行判断并做出躲开的动作。 群体智能体 如其名，与自治智能体相对，“群体智能”一般用于编队的AI或者集群的AI。例如足球游戏里，AI操控一方所有球员互相配合传球踢球。又或者射击游戏里，AI操控一支小队通过战术进攻据点。","text":"什么是游戏AI AI（artificial intelligence）即人工智能，游戏中的AI是让游戏里的对象具有一定的智能化，能够思考和决策，比如RPG游戏中的怪物知道有玩家攻击自己时进行反击，当玩家逃跑时会进行追击，当玩家远离自己时则放弃追击，这一系的决策和动作就是游戏中的AI要做的。和现下流行的人工智能不一样的是游戏里的AI还不能那么智能，不过现在已经在尝试将机器学习和游戏结合，让游戏对象更智能。\b 自治智能体 正如其命，有自治动作的智能体称之为“自治智能体”。在《看门狗》《GTA》里，街上走路的人群或者开动的汽车 就是一种自治智能体。主角开车如果冲向它们，这些自治智能体能够自行判断并做出躲开的动作。 群体智能体 如其名，与自治智能体相对，“群体智能”一般用于编队的AI或者集群的AI。例如足球游戏里，AI操控一方所有球员互相配合传球踢球。又或者射击游戏里，AI操控一支小队通过战术进攻据点。 游戏AI相关的知识点 游戏中的对象想要智能必须要具备以下3点： 1. 对当前环境数据的搜集即感知， 比如当前自己所在的位置，血量以及前后左右有什么等； 2. 对当前环境的认识进行决策，比如检查自己的血量，比较少则逃跑，多则可以进行攻击； 3. 对决策执行相应的行为，比如使用技能，逃跑等； 感知相关知识点 \b为了让游戏里面的对象具有向人一样的智能，那么人所具有的感知系统：听觉、视觉和触觉都要在游戏进行模拟，才能让游戏里的智能对象具有类似人一样的的感知，当然在游戏里不能完全模拟人的的听觉、视觉和触觉，有的时候游戏里为了提高关卡难度也能让智能体感知到在真实世界里的人不能获取的感知，比如：能感知到自己背后的怪物，预知敌方的下一步行动，或者获得其他系统的相关信息。在这里就要引入一个叫做黑板概念，“黑板”简单来说就是可访问的共享数据，用于多模块间的数据共享。 听觉 视觉 触觉 黑板 决策相关知识点 行为相关知识点 参考文献 [1] 游戏AI研究（一）：感知AI [2] 游戏AI之初步介绍","categories":[],"tags":[]},{"title":"Laya踩坑日记","slug":"Laya/Laya踩坑日记","date":"2020-06-03T10:40:38.000Z","updated":"2021-03-03T14:33:17.588Z","comments":true,"path":"2020/06/03/Laya/Laya踩坑日记/","link":"","permalink":"http://yoursite.com/2020/06/03/Laya/Laya%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"Laya版本 2.6.0 1. 修改Laya对象位置时，记得克隆一个Vector3对象，因为JS的对象都是引用 HBox或VBox必须要设置宽或高，并且在编辑器状态下是不会计算布局的（不知道是bug还是故意的，必须要运行才能看结果）","text":"Laya版本 2.6.0 1. 修改Laya对象位置时，记得克隆一个Vector3对象，因为JS的对象都是引用 HBox或VBox必须要设置宽或高，并且在编辑器状态下是不会计算布局的（不知道是bug还是故意的，必须要运行才能看结果） 发布微信时js压缩出错，原因竟然是压缩Json里面多加了一项，如图：","categories":[],"tags":[]},{"title":"矩阵","slug":"数学物理/矩阵","date":"2020-04-01T03:02:05.000Z","updated":"2021-03-03T14:33:17.592Z","comments":true,"path":"2020/04/01/数学物理/矩阵/","link":"","permalink":"http://yoursite.com/2020/04/01/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/%E7%9F%A9%E9%98%B5/","excerpt":"矩阵的基础定义 矩阵是3D数学的重要基础，它主要用来描述两个坐标系之间的关系，通过定义一种运算将一个坐标系中的向量转换到另一个坐标系中。 矩阵的数学定义 在线性代数中，矩阵就是以行和列形式组织的矩形数字块。例如下列的一个3x4的矩阵： \\[\\begin{bmatrix} 0&amp;-1&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;4 \\\\ 2&amp;1&amp;3&amp;-4 \\end{bmatrix}\\]","text":"矩阵的基础定义 矩阵是3D数学的重要基础，它主要用来描述两个坐标系之间的关系，通过定义一种运算将一个坐标系中的向量转换到另一个坐标系中。 矩阵的数学定义 在线性代数中，矩阵就是以行和列形式组织的矩形数字块。例如下列的一个3x4的矩阵： \\[\\begin{bmatrix} 0&amp;-1&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;4 \\\\ 2&amp;1&amp;3&amp;-4 \\end{bmatrix}\\] 方阵 行和列数相同的矩阵被定义为方阵，例如：2x2, 3x3, 4x4的矩阵都是方阵。方阵的对角线元素就是行号和列号都相同的元素。例如：3x3的矩阵M的对角线元素为\\(m_{11}\\), \\(m_{22}\\), \\(m_{33}\\)。其他元素为非对角线元素。 对角矩阵 非对角线元素都为0的元素为对角矩阵。 单位矩阵 单位矩阵是一种特殊的对角矩阵。它的对角元素都为1，非对角元素都为0. 单位矩阵非常特殊，因为它是矩阵的乘法单位元，其性质是用任意一个矩阵乘以单位矩阵，都将得到原矩阵。 矩阵运算 矩阵转置 一个r x c的矩阵M。M的转置记作\\(M^T\\), 是一个c x r的矩阵，它的列由M的行组成。可以从另一方面理解，\\(M_{ij}^T = M_{ji}\\) ,及沿着对角线翻折。例如： \\(\\begin{bmatrix} 0&amp;-1&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;4 \\\\ 2&amp;1&amp;3&amp;-4 \\end{bmatrix}^T = \\begin{bmatrix} 0&amp;1&amp;2 \\\\ -1&amp;0&amp;1 \\\\ 1&amp;1&amp;3 \\\\ 1&amp;4&amp;-4 \\end{bmatrix}\\) 标量与矩阵乘法 \\(k\\textbf{M}=k\\begin{bmatrix} m_{11}&amp;m_{12}&amp;m_{13} \\\\ m_{21}&amp;m_{22}&amp;m_{23} \\\\ m_{31}&amp;m_{32}&amp;m_{33} \\end{bmatrix}= \\begin{bmatrix} km_{11}&amp;km_{12}&amp;km_{13} \\\\ km_{21}&amp;km_{22}&amp;km_{23} \\\\ km_{31}&amp;km_{32}&amp;km_{33} \\end{bmatrix}\\) 矩阵乘法 在某些情况下，两个矩阵可以相乘。决定矩阵能否相乘以及怎么计算结果的法则初看起来有些奇怪。一个r x n 矩阵A能够乘以一个n x c的矩阵B,结果是一个r x c的矩阵，记作 AB。矩阵乘法计算如下：记r x n矩阵A与n x c矩阵B的积r x c 矩阵AB为C。 C的任意元素\\(\\textbf{C}_{ij}\\)等于A的第i行向量与B的第j列向量的点乘结果。 正式定义为： \\(c_{ij} = \\sum_{k=1}^{n}a_{ik}b_{kj}\\) 矩阵乘法满足的定律（前提是矩阵乘法有意义）： 任意矩阵M乘以单位矩阵I的到原矩阵 MI=IM=M 矩阵乘法不满足交换律，即 AB \\(\\neq\\) BA 矩阵乘法满足结合律，即 (AB)C=A(BC) 矩阵的转置\\((AB)^T = B^TA^T\\) 向量与矩阵的乘法 因为向量能被当作是一个行或一列的矩阵，所以能够用上一节的矩阵乘法来计算。但是左乘矩阵和右乘矩阵这个两个的区别特别重要。例如，用矩阵A， B和C转换向量v,用行向量记法记作vABC。注意矩阵按顺序从左往右列出。如果使用列向量，矩阵放在左边，转换从右往左发生，这种情况下应该记作CBAv 矩阵的几何定义 一般来说，方阵能够描述任意线性变换，比如： 旋转 缩放 投影 镜像 仿射","categories":[{"name":"数学物理","slug":"数学物理","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[]},{"title":"游戏寻路介绍","slug":"游戏/寻路算法/游戏寻路介绍","date":"2020-04-01T03:02:05.000Z","updated":"2021-03-03T14:33:17.600Z","comments":true,"path":"2020/04/01/游戏/寻路算法/游戏寻路介绍/","link":"","permalink":"http://yoursite.com/2020/04/01/%E6%B8%B8%E6%88%8F/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%B8%B8%E6%88%8F%E5%AF%BB%E8%B7%AF%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"","categories":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"寻路算法","slug":"游戏/寻路算法","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"向量","slug":"数学物理/向量","date":"2020-04-01T03:02:05.000Z","updated":"2021-03-03T14:33:17.591Z","comments":true,"path":"2020/04/01/数学物理/向量/","link":"","permalink":"http://yoursite.com/2020/04/01/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/%E5%90%91%E9%87%8F/","excerpt":"向量的基本定义 数学定义 向量就是一个数列，是一个只有大小和方向的一个数学量，和标量不同，标量是一个只有大小的量。向量的记法如下： 行向量:a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\) 列向量:a=\\(\\begin{bmatrix}1\\\\2\\\\3\\end{bmatrix}\\) 几何定义 向量是有大小和方向的有向线段。向量和点不同点表示了一个固定的位置然而向量是没有位置的，你画在任何地方都行，因为向量表示它在各个方向上的位移关系。向量的几何表示如下图：","text":"向量的基本定义 数学定义 向量就是一个数列，是一个只有大小和方向的一个数学量，和标量不同，标量是一个只有大小的量。向量的记法如下： 行向量:a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\) 列向量:a=\\(\\begin{bmatrix}1\\\\2\\\\3\\end{bmatrix}\\) 几何定义 向量是有大小和方向的有向线段。向量和点不同点表示了一个固定的位置然而向量是没有位置的，你画在任何地方都行，因为向量表示它在各个方向上的位移关系。向量的几何表示如下图： 向量的运算 负向量 负向量就是在一个向量的前面加上一个负号。例如：a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\),它的负向量就是\\(\\begin{bmatrix}-1&amp;-2&amp;-3\\end{bmatrix}\\) 运算法则 -\\(\\begin{bmatrix}a_1&amp;a_2&amp;\\cdots&amp;a_n\\end{bmatrix}\\)=\\(\\begin{bmatrix}-a_1&amp;-a_2&amp;\\cdots&amp;-a_n\\end{bmatrix}\\) 几何解释 向量变负，将得到一个和原向量大小相等，方向相反的向量。如下图： 标量与向量的乘法 向量与标量相乘，结果将得到一个与原向量平行，但长度不同或方向相反的向量。 运算法则 将向量中的每个元素和标量相乘。公式如下： \\[k\\begin{bmatrix}a_1\\\\ a_2\\\\ \\vdots\\\\a_n\\end{bmatrix}=\\begin{bmatrix}ka_1\\\\ ka_2\\\\ \\vdots\\\\ka_n\\end{bmatrix}\\] 几何解释 按照k的缩放因子进行缩放，如下： 向量的加法和减法 向量相加和相减的前提是两向量维度相同。结果向量的维度和原向量相同。 运算法则 将对应的向量元素相加。公式如下： \\[\\begin{bmatrix}a_1\\\\ a_2\\\\ \\vdots\\\\a_n\\end{bmatrix}+\\begin{bmatrix}b_1\\\\ b_2\\\\ \\vdots\\\\b_n\\end{bmatrix}=\\begin{bmatrix}a_1+b_1\\\\ a_2 + b_2\\\\ \\vdots\\\\a_n+b_n\\end{bmatrix}\\] 减法的操作可以转换为加法：a-b=a+(-b) 几何解释 向量点乘(内积) 运算法则 向量点乘就是对应分量乘积的和，其结果是一个标量： \\[\\begin{bmatrix}a_1\\\\ a_2\\\\ \\vdots\\\\a_n\\end{bmatrix}\\cdot\\begin{bmatrix}b_1\\\\ b_2\\\\ \\vdots\\\\b_n\\end{bmatrix}=a_1b_1+a_2b_2+\\cdots+a_nb_n\\] 用连加符号简写为： \\(a\\cdot b=\\sum_{i=1}^{n}a_ib_i\\) 几何解释 一般来说，点乘结果描述了两个向量的“相似”程度，点乘结果越大，两向量越相近。如下图： 点乘等于向量大小与向量夹角的\\(cos\\)值的积： \\(a\\cdot b=||a|| ||b||cos{\\theta}\\) 向量叉乘(叉积) 运算法则 向量叉乘得到一个向量且不满足交换律，点乘满足交换律。公式如下： \\[\\begin{bmatrix}x_1\\\\y_1\\\\z_1\\end{bmatrix}\\times\\begin{bmatrix}x_2\\\\y_2\\\\z_2\\end{bmatrix} =\\begin{bmatrix}y_1z_2 -z_1y_2\\\\z_1x_2-x_1z_2\\\\x_1y_2-y_1x_2\\end{bmatrix}\\] 几何解释 （1）.叉乘得到的向量垂直于原来的两个向量，如下图： 这里写图片描述 \\(a\\times b\\)的长度等于向量的大小与向量的夹角\\(sin\\)值的积，如下： \\[||a\\times b||=||a||||b||sin{\\theta}\\] 已经证明了\\(a\\times b\\)垂直于a,b。但是垂直于a,b有两个方向。\\(a\\times b\\)指向哪个方向呢？通过将a的头与b的尾相连，并检测从a到b是顺时针还是逆时针。如果在左手坐标系中，左手四个（除大拇指）指母重贴与a,b向量的方向大拇指指向的方向就是\\(a\\times b\\)垂直的方向。右手坐标的也相同只是使用右手来判断。 （2）.\\(||a\\times b||\\)也等于两向量组成的平行四边形的面积。 向量大小(长度或模) 运算法则 公式如下： \\[||v||=\\sqrt{v_1^2+v_2^2+\\cdots+v_n^2}\\] 或 \\[||v||=\\sqrt{\\sum_{i=1}^{n} v_i^2}\\] 距离公式 同一坐标系中的两个点的距离，实际上可以看作是两个点构成的一个向量，那么两个点的距离就等于此向量的模长。 运算法则 距离\\(（a,b）=||b-a||=\\sqrt{(b_x-a_x)^2+(b_y-a_y)^2+(b_z-a_z)^2}\\) 标准化向量 对于许多向量，我们只关心它的方向而不是大小。在这种情况下使用单位向量将会非常方便。单位向量就是大小为1的向量，单位向量也被称之为标准向量或更简洁地称为法线。 运算法则 对于任意非零向量v，都能计算出一个和v方向相同的单位向量\\(v_{norm}\\)。这个过程被称作向量的标准化，要标准化向量，将向量除以他的大小（模）即可。公式如下： \\[v_{norm}=\\frac{v}{||v||},v\\ne 0\\] 注意：零向量是不能被标准化的，因为除零是没有定义的。 几何解释 如下图： 向量投影 给定两个向量v和n，能将v分解成两个分量：\\(v_{||}和v_{\\perp}\\)。他们分别平行和垂直于n，并满足\\(v=v_{||}+v_{\\perp}\\)。一般称平行分量\\(v_{||}\\)为v在n上的投影。 运算法则 公式如下： \\[v_{||}=n\\frac{v\\cdot n}{||n||^2}\\] \\[v_{\\perp}=v-v_{||}\\] 几何解释 如下图： 总结 向量是用来表示方位和距离的，也就是映射到每个轴的偏移。向量的常规运算有：向量与标量乘法，向量加减法，向量点乘，向量叉乘。 参考文献 [1] Fletcher Dunnlan Parberry. 3D数学基础：图形与游戏开发.北京:清华大学出版社.2005.1.","categories":[{"name":"数学物理","slug":"数学物理","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[]},{"title":"CentOS开机自启动","slug":"Linux/CentOS开机自启动","date":"2020-03-15T05:20:51.000Z","updated":"2021-03-03T14:33:17.589Z","comments":true,"path":"2020/03/15/Linux/CentOS开机自启动/","link":"","permalink":"http://yoursite.com/2020/03/15/Linux/CentOS%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/","excerpt":"在CentOS系统启动时，自动运行脚本 自己新建一个脚本,如/usr/local/harbor/harbor-service.sh,脚本的功能是去启动harbor容器仓库服务器，代码如下： 12systemctl start docker #启动dockerdocker-compose -f /usr/local/harbor/docker-compose.yml start","text":"在CentOS系统启动时，自动运行脚本 自己新建一个脚本,如/usr/local/harbor/harbor-service.sh,脚本的功能是去启动harbor容器仓库服务器，代码如下： 12systemctl start docker #启动dockerdocker-compose -f /usr/local/harbor/docker-compose.yml start 执行如下命令,给该脚本添加可执行的权限 1chmod +x /usr/local/harbor/harbor-service.sh 执行如下命令将/etc/rc.d/rc.local文标记为可执行文件 在centos7中,/etc/rc.d/rc.local文件的权限被降低了,开机的时候执行在自己的脚本是不能起动一些服务的,执行下面的命令可以文件标记为可执行的文件 1chmod +x /etc/rc.d/rc.local 打开/etc/rc.d/rc.local文件,在最后面添加如下脚本 1/usr/local/harbor/harbor-service.sh 这样,harbor-service.sh这个脚本在开机的时候就会被执行了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"CentOS安装Docker","slug":"服务器/Docker/CentOS安装Docker","date":"2020-03-10T03:02:33.000Z","updated":"2021-03-03T14:33:17.593Z","comments":true,"path":"2020/03/10/服务器/Docker/CentOS安装Docker/","link":"","permalink":"http://yoursite.com/2020/03/10/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/CentOS%E5%AE%89%E8%A3%85Docker/","excerpt":"OS需求 CentOS 7 centos-extra必须启用，默认是启用的 卸载老的版本（如果有安装过的） 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 在/var/lib/docker目录中的镜像，容器和网络被保留了，如果不需要也可以将其移除掉","text":"OS需求 CentOS 7 centos-extra必须启用，默认是启用的 卸载老的版本（如果有安装过的） 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 在/var/lib/docker目录中的镜像，容器和网络被保留了，如果不需要也可以将其移除掉 安装Docker Engine社区版 Docker官方提供了3中安装方式，如下： - 大多数用户采用设置Docker仓库的方式进行安装，这也是简单的安装和更新的方式，本文也只将介绍此安装方法，其他的安装方式，参考官方文档 - 下载RPM包进行安装并且手动的安装和管理更新，这种方式适合在没有没有网的环境下安装 - 在装测试和开发环境，有的用户选择使用自动化脚本安装，生成环境不推荐 设置Docker仓库 在一个新系统安装时，首先需要设置一个Docker仓库，如果已经添加过仓库，可以跳过这步。 1. 安装需要的包：yum-utils ，此包提供了yum-config-manager工具；以及device-mapper-persistent-data 和 lvm2 （devicemapper存储驱动需要它们） 123sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用下面的命令设置一个稳定版的Docker仓库 123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装 安装最新版 使用下面的命令安装最新版Docker引擎，如下： 1sudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose 安装指定版本 安装指定版本的的Docker引擎 1. 先列出有哪些版本可以安装，命令如下： 123456yum list docker-ce --showduplicates | sort -r--命令列出的结果docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 安装指定版本，命令如下： 1sudo yum install -y docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 启动Docker-CE引擎 命令如下： 1sudo systemctl start docker 验证Docker-CE是否安装成功 命令如下： 1sudo docker run hello-world 登录DockerHub 1docker login 卸载Docker-CE 卸载包 1sudo yum remove docker-ce 删除镜像，容器，卷以及自定义的配置 1sudo rm -rf /var/lib/docker","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Docker","slug":"服务器/Docker","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/"}],"tags":[{"name":"Dokcer","slug":"Dokcer","permalink":"http://yoursite.com/tags/Dokcer/"}]},{"title":"Mysql安装与配置","slug":"服务器/服务软件/Mysql安装与配置","date":"2020-02-07T08:25:39.000Z","updated":"2021-03-03T14:33:17.593Z","comments":true,"path":"2020/02/07/服务器/服务软件/Mysql安装与配置/","link":"","permalink":"http://yoursite.com/2020/02/07/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/Mysql%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"参考","text":"参考","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Redis安装与配置","slug":"服务器/服务软件/Redis安装与配置","date":"2020-01-15T09:15:18.000Z","updated":"2021-03-03T14:33:17.594Z","comments":true,"path":"2020/01/15/服务器/服务软件/Redis安装与配置/","link":"","permalink":"http://yoursite.com/2020/01/15/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"安装 yum 安装 12yum info redis // 查看当前源的redis最新版本信息yum install redis","text":"安装 yum 安装 12yum info redis // 查看当前源的redis最新版本信息yum install redis 源码安装 1234567# 下载地址从[官网](https://redis.io/download)获取最新的wget http://download.redis.io/releases/redis-3.2.10.tar.gztar -zxvf redis-3.2.10.tar.gzcd redis-3.2.10makemake install 注意：如果没有c编译环境记得安装，如下： 1yum -y install gcc gcc-c++ kernel-devel //安装gcc、c++编译器以及内核文件 注意：如果没有jemalloc库，在make的时候添加如下参数： 1make MALLOC=libc 安装成功后，查看redis-server的位置。 1whereis redis-server 配置 配置文件需要启动后才会生成，如何启动参见“启动”章节， 不同的安装方式配置文件放的位置不太一样， yun安装：/etc/redis.conf 源码安装,需要收到将配置文件拷贝到/etc目录： 12cd /xxx/redis-3.2.10cp redis.conf /etc/ 基础配置 123456# 端口配置port 6379# 让redis后台运行，默认是nodaemonize yes# 日志文件配置logfile \"/var/log/redis.log\" 持久化配置 快照RDB持久化配置 123456789101112131415161718# Save the DB on disk:# 设置sedis进行数据库镜像的频率。# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）。# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）。# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）。save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yes# 在进行镜像备份时,是否进行压缩。yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间。rdbcompression yes# 一个CRC64的校验就被放在了文件末尾，当存储或者加载rbd文件的时候会有一个10%左右的性能下降，为了达到性能的最大化，你可以关掉这个配置项。rdbchecksum yes# 快照的文件名dbfilename dump.rdb# 存放快照的目录dir /var/lib/redis AOF持久化配置 12345678910111213141516# 是否开启AOF，默认关闭（no）appendonly yes# 指定 AOF 文件名appendfilename appendonly.aof# Redis支持三种不同的刷写模式：# appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。# appendfsync no #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。#在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO上的冲突。#设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yesno-appendfsync-on-rewrite yes #当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。auto-aof-rewrite-percentage 100#当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。auto-aof-rewrite-min-size 64mb 两种持久化的区别 1）如果能接受几分钟的数据丢失的话，建议选择快照RDB 2）要是不允许数据丢失，则需要用AOF来持久化 关于数据恢复： RDB的启动时间会更短，原因有两个： 一是RDB文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了。 另一个原因是RDB文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作，所以在CPU消耗上要远小于AOF日志的加载。 注意： AOF(Append Only File)比RDB方式有更好的持久化性。由于在使用AOF持久化方式时，Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。 AOF的完全持久化方式同时也带来了另一个问题，持久化文件会变得越来越大。(比如我们调用INCR test命令100次，文件中就必须保存全部的100条命令，但其实99条都是多余的。因为要恢复数据库的状态其实文件中保存一条SET test 100就够了)。为了合并重写AOF的持久化文件，Redis提供了bgrewriteaof命令。 Redis重启如何载入数据的 通过日志可以很清楚的知道redis通过那个文件来取数据的： RDB: * DB loaded from disk: 0.000 seconds AOF: * DB loaded from append only file: 0.000 seconds 保存数据则是： RDB: * DB saved on disk AOF: * Calling fsync() on the AOF file. 重启时将按照以下优先级恢复数据到内存 如果只配置AOF,重启时加载AOF文件恢复数据。 如果同时 配置了RBD和AOF,启动是只加载AOF文件恢复数据。 如果只配置RBD,启动是讲加载dump文件恢复数据。 如果你先开启了RDB模式，想再开启AOF模式，先执行bgrewriteaof命令，不然会因为恢复数据的优先级问题，数据都没有了。 为了防止悲剧发生，注意多备份，AOF模式，记得使用脚本定期执行bgrewriteaof命令。 脚本如下，可以结合Linux Crontab来使用，定期执行。 12echo 'bgrewriteaof redis 6379'redis-cli -p 6379 bgrewriteaof 启动 普通启动 首次启动，命令如下： 1redis-server 首次启动会生成默认配置文件redis.conf 配置文件生成后，后面每次启动就可以直接跟上配置文件了，如下： 1redis-server /etc/redis.conf ## 开机自启动 在/etc/rc.d/rc.local文件尾部添加一行，如下： 1redis-server /etc/redis.conf 检查一下rc.local有没有执行权限，如果没有加上执行权限，如下： 1chmod +x /etc/rc.d/rc.local 如果未执行成功,查看logfile.log日志,寻找原因。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Git服务器搭建","slug":"服务器/服务软件/Git服务器搭建","date":"2019-12-27T07:08:26.000Z","updated":"2021-03-03T14:33:17.593Z","comments":true,"path":"2019/12/27/服务器/服务软件/Git服务器搭建/","link":"","permalink":"http://yoursite.com/2019/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","excerpt":"CentOS安装与配置Git","text":"CentOS安装与配置Git 使用yum命令安装： 1yum install -y git 为Git单独创建一个用户 创建用户 1adduser git 修改密码 1passwd git 创建Git仓库 创建一个目录存放Git仓库，目录/data/git 12mkdir /data/gitgit init --bare Puzzle.git 将Puzzle.git的拥有者修改为上面创建的git用户 1chown git:git Puzzle.git 开启ssh key登录 编辑/etc/ssh/sshd_config文件,把下下面三个的注释打开，如果没有自行新建 123RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 禁用git用户的shell登陆 编辑/etc/passwd文件，找到git用户对应的配置，将最后一个分号的内容修改成/usr/bin/git-shell,如下： 12git:x:1000:1001::/home/git:/bin/bash #改成如下，git:x:1000:1001::/home/git:/usr/bin/git-shell 输入git用户的密码进行验证，至此已完成在服务器配置Git仓库的任务，但是这样每次更新都会要求输入密码，特麻烦，下面章节将介绍更安全便捷的访问方式。 客户端配置 Windows配置 Git的客户端选择使用TortoiseGit。 下载TortoiseGit，下载地址如下： https://tortoisegit.org/download/ 安装TortoiseGit，就跟安装普通应用程序一样，下一步-&gt;下一步 生成Putty Key, 成功安装TortoiseGit后在其安装目录下的bin目录下会有一个PuttyGen的应用程序用于生成Putty key 启动PuttyGen生成并保存key,如下图： 生成KEY 保存KEY 拷贝公匙到服务器的/home/git/.ssh/authorized_keys文件末尾，注意如果没有相应文件夹或文件请自行创建,注意权限参见“遇到的问题”章节 使用TortoiseGit下载Git仓库 在一个空目录邮件单机，选择Git Clone...,如下图： Mac/Linux配置 将~/.ssh目录下的id_rsa.pub内容追加到到服务器的/home/git/.ssh/authorized_keys文件末尾。如果没有id_rsa.pub, 可以用ssh-keygen来创建 在其他电脑上测试能否克隆远程仓库 1git clone ssh://git@192.168.0.172:22/data/git/Puzzle.git 遇到的问题 在对应用户（git）目录下.ssh的目录权限必须是700， authorized_keys文件必须是600的权限","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Linux网络配置","slug":"Linux/Linux网络配置","date":"2019-12-18T08:41:57.000Z","updated":"2021-03-03T14:33:17.590Z","comments":true,"path":"2019/12/18/Linux/Linux网络配置/","link":"","permalink":"http://yoursite.com/2019/12/18/Linux/Linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","excerpt":"本文主要介绍如何手动配置Linux的网络","text":"本文主要介绍如何手动配置Linux的网络 网卡参数配置文件 &lt;font color=#c7254e&gt;基本信息文件：/etc/sysconfig/network-scripts/ifcfg-enp0s3(文件名可能不一样ifcfg-*) &lt;/font&gt; &lt;font color=#c7254e&gt;网关配置文件：/etc/sysconfig/network&lt;/font&gt; &lt;font color=#c7254e&gt;DNS配置文件：/etc/resolv.conf&lt;/font&gt; 基本命令 nmcli 网络管理命令行客服端 nmcli d :限制网卡设备 nmtui 网络管理图像操作界面 nmtui ：启动网络图像编辑界面 ip ip addr :查看ip地址 其他命令 service network restart : 重启网络 实践 配置静态IP 编辑IP配置文件 vi /etc/sysconfig/network-scripts/ifcfg-enp0s3 在ifcfg-enp0s3文件中设置如下内容： HWADDR=08:00:27:6C:FF:91 TYPE=Ethernet BOOTPROTO=static DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=no IPADDR=192.168.0.88 IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPV6_FAILURE_FATAL=no NAME=enp0s3 UUID=ea68db6e-461e-427d-b9a8-bfcf6e1a4fc6 ONBOOT=yes 配置网关 编辑网关配置文件 vi /etc/sysconfig/network 添加下面的行 NETWORKING=yes HOSTNAME=centos7 GATEWAY=10.1.1.253 配置DNS服务器 编辑DNS服务器配置文件 vi /etc/resolv.conf 添加如下行，DNS服务器的地址，根据具体情况填写 nameserver 8.8.8.8 nameserver 8.8.4.4 重启网络 /etc/init.d/network restart 检查配置结果 ip addr 1: lo: mtu 65536 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 08:00:27:6c:ff:91 brd ff:ff:ff:ff:ff:ff inet 192.168.0.88/24 brd 192.168.0.255 scope global enp0s3 valid_lft forever preferred_lft forever inet6 fe80::a00:27ff:fe6c:ff91/64 scope link valid_lft forever preferred_lft forever","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"网络配置","slug":"网络配置","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"}]},{"title":"Linux常用命令","slug":"Linux/Linux常用命令","date":"2019-12-18T02:34:46.000Z","updated":"2021-03-03T14:33:17.589Z","comments":true,"path":"2019/12/18/Linux/Linux常用命令/","link":"","permalink":"http://yoursite.com/2019/12/18/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"文件操作 网络相关 查看端口占用情况： lsof -i tcp:80 系统系信息相关 查看进程情况： top (shift + p：cpu排序，shift+m:内存排序)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"}]},{"title":"Nodejs 安装教程","slug":"服务器/服务软件/nodejs安装","date":"2019-12-08T16:00:00.000Z","updated":"2021-03-03T14:33:17.596Z","comments":true,"path":"2019/12/09/服务器/服务软件/nodejs安装/","link":"","permalink":"http://yoursite.com/2019/12/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/nodejs%E5%AE%89%E8%A3%85/","excerpt":"从官网下下载最新的nodejs，https://nodejs.org/en/download/ 通过ftp工具上传到linux服务，解压安装包 1tar -xvf node-v10.16.0-linux-x64.tar.xz","text":"从官网下下载最新的nodejs，https://nodejs.org/en/download/ 通过ftp工具上传到linux服务，解压安装包 1tar -xvf node-v10.16.0-linux-x64.tar.xz 移动并改名文件夹（不改名也行） 123cd /usr/local/mv /var/ftp/pub/node-v10.16.0-linux-64 . //后面的.表示移动到当前目录mv node-v10.16.0.0-linux-64/ nodejs 让npm和node命令全局生效 12ln -s /usr/local/nodejs/bin/npm /usr/local/bin/ln -s /usr/local/nodejs/bin/node /usr/local/bin/ 查看nodejs是否安装成功 12node -vnpm -v","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"mysql索引","slug":"数据库/Mysql/mysql索引","date":"2019-12-08T16:00:00.000Z","updated":"2021-03-03T14:33:17.592Z","comments":true,"path":"2019/12/09/数据库/Mysql/mysql索引/","link":"","permalink":"http://yoursite.com/2019/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/mysql%E7%B4%A2%E5%BC%95/","excerpt":"索引作用 在索引列上，除了上面提到的有序查找之外，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。","text":"索引作用 在索引列上，除了上面提到的有序查找之外，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。 例如，有3个未索引的表t1、t2、t3，分别只包含列c1、c2、c3，每个表分别含有1000行数据组成，指为1～1000的数值，查找对应值相等行的查询如下所示。 SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3 此查询结果应该为1000行，每行包含3个相等的值。在无索引的情况下处理此查询，必须寻找3个表所有的组合，以便得出与WHERE子句相配的那些行。而可能的组合数目为1000×1000×1000（十亿），显然查询将会非常慢。 如果对每个表进行索引，就能极大地加速查询进程。利用索引的查询处理如下。 （1）从表t1中选择第一行，查看此行所包含的数据。 （2）使用表t2上的索引，直接定位t2中与t1的值匹配的行。类似，利用表t3上的索引，直接定位t3中与来自t1的值匹配的行。 （3）扫描表t1的下一行并重复前面的过程，直到遍历t1中所有的行。 在此情形下，仍然对表t1执行了一个完全扫描，但能够在表t2和t3上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。 利用索引，MySQL加速了WHERE子句满足条件行的搜索，而在多表连接查询时，在执行连接时加快了与其他表中的行匹配的速度。 创建索引 在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。 ALTER TABLE ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。 ALTER TABLE table_name ADD INDEX index_name (column_list) ALTER TABLE table_name ADD UNIQUE (column_list) ALTER TABLE table_name ADD PRIMARY KEY (column_list) 其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。 CREATE INDEX CREATE INDEX可对表增加普通索引或UNIQUE索引。 CREATE INDEX index_name ON table_name (column_list) CREATE UNIQUE INDEX index_name ON table_name (column_list) table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。 索引类型 在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。 PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。 下面的SQL语句对students表在sid上添加PRIMARY KEY索引。 ALTER TABLE students ADD PRIMARY KEY (sid) 删除索引 可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。 DROP INDEX index_name ON talbe_name ALTER TABLE table_name DROP INDEX index_name ALTER TABLE table_name DROP PRIMARY KEY 其中，前两条语句是等价的，删除掉table_name中的索引index_name。 第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。 如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。 查看索引 mysql&gt; show index from tblname; mysql&gt; show keys from tblname; · Table 表的名称。 · Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。 · Key_name 索引的名称。 · Seq_in_index 索引中的列序列号，从1开始。 · Column_name 列名称。 · Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。 · Cardinality 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。 · Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。 · Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。 · Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。 · Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。 · Comment 转载：http://blogold.chinaunix.net/u3/93470/showart_2001536.html","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"数据库/Mysql","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"}],"tags":[{"name":"服务器工具","slug":"服务器工具","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"Nginx安装与配置","slug":"服务器/服务软件/nginx安装与配置","date":"2019-12-08T16:00:00.000Z","updated":"2021-03-03T14:33:17.595Z","comments":true,"path":"2019/12/09/服务器/服务软件/nginx安装与配置/","link":"","permalink":"http://yoursite.com/2019/12/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"简介 Nginx是个web，反向代理, 负载均衡, 邮件代理和HTTP缓存服务器.","text":"简介 Nginx是个web，反向代理, 负载均衡, 邮件代理和HTTP缓存服务器. # 安装 ## centos安装 1.安装准备 sudo yum install yum-utils 2.设置yum仓库，使用下面的内容创建一个/etc/yum.repos.d/nginx.repo文件 [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 3.安装Nginx sudo yum install nginx 配置 通常Nginx的配置放在下面几目录中： - /etc/nginx/nginx.conf , - /usr/local/etc/nginx/nginx.conf 或 - /usr/local/nginx/conf/nginx.conf 先看看默认的配置文件，如下： 1234567891011121314151617181920212223242526272829user nginx; #用户worker_processes 1; #工作进程数量error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn; #错误日志pid &#x2F;var&#x2F;run&#x2F;nginx.pid; #定义一个存储主进程ID文件events &#123; worker_connections 1024; #最大同时连接数&#125;http &#123; include &#x2F;etc&#x2F;nginx&#x2F;mime.types; #扩展名对应的MIME类型 default_type application&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; #访问日志文件 sendfile on; #非阻塞磁盘IO #tcp_nopush on; keepalive_timeout 65; #连接超时值 #gzip on; include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; #包含其他配置文件,在这目录下有一个default.conf文件，里面配置了服务器上下文&#125; 配置文件由上下文（模块）与指令两部组成的树形结构指令集，子上下文的指令会覆盖父上下的指令。Nginx的核心上下文有： - 主上下文或全局上下文 - events上下文 - http上下文 - server上下文 - location上下文 其他上下文参见官网文档 ## 配置 ### 核心上下文 #### 主上下文 12345# 最外层的上下文，者是主上下文. . .context &#123; . . .&#125; Events上下文 123456# main contextevents &#123; # events context . . .&#125; HTTP上下文 1234567891011# main context. . .events &#123; # events context . . .&#125;http &#123; # http context . . .&#125; Server上下文 1234567891011121314# main contexthttp &#123; # http context server &#123; # first server context &#125; server &#123; # second server context &#125;&#125; Location上下文 1234567891011121314151617181920212223242526# main contextserver &#123; # server context #location [modifier] path # = - 精准匹配 # ^~ - 优先匹配 # ~ &amp;&amp; ~* - 正则匹配 # no modifier - 前缀匹配 location /match/criteria &#123;s # first location context &#125; location /other/criteria &#123; # second location context location nested_match &#123; # first nested location &#125; location other_nested &#123; # second nested location &#125; &#125;&#125; 核心配置指令 1234567891011121314151617181920212223242526272829303132# 指定用户user www www;# 指定工作进程数量或者自动（根据cpu等相关信息自动选择）worker_processes 2|auto;# 指定日志文件error_log /var/log/nginx-error.log info;# 访问日志文件（http, server, location, if in location, limit_except）access_log /var/log/nginx-access.log;# 监听指令并为默认服务器listen *:80 default_server;# 服务器名字(域名)server_name qilezaitu.top# 指定根目录指令root /var/www/qilezaitu;# 指定首页文件index index.html index.htm index.php;# try_files指令，在try_files列表你查找文件 ，其中$uri就是用户请求的uritry_files $uri index.html =404;# 包含指令,包含其他配置或文件include /etc/nginx/conf.d/*.conf;# 返回指令return 200 \"Hello from netguru.co\"; 优化配置指令 1234567#开启各类优化配置tcp_nodelay ontcp_nopush onsendfile onkeepalive_timeout 65;worker_connections 4096;worker_rlimit_nofile 8192; 常用服务器配置 此节将简单的配置一下几种服务器，Web服务器,负载均衡服务器和代理服务器。 在/etc/nginx/nginx.conf文件中进行配置，如下： 12345678910111213141516171819202122232425262728293031323334user nginx; worker_processes auto;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;worker_rlimit_nofile 8192;events &#123; worker_connections 4096;&#125;http &#123; include /etc/nginx/mime.types; index index.html index.htm index.php; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; keepalive_timeout 65; server_names_hash_bucket_size 128; # 包含conf.d目录下的所有配置，后续的服务器配置都将在这个目录进行 include /etc/nginx/conf.d/*.conf;&#125; 最后将/etc/nginx/conf.d/的默认配置文件备份，下面将在此目录下配置不同的服务器。 Web服务器配置 在/etc/nginx/conf.d/目录下新建一个配置文件命名为home.qilezaitu.top.conf 内容如下： 12345678910server &#123; listen *:80; server_name home.qilezaitu.top www.home.qilezaitu.top; access_log /var/log/nginx/access.log main; root /usr/share/nginx/html/blog; location / &#123; &#125;&#125; 负载均衡服务器配置 在/etc/nginx/conf.d/目录下新建一个配置文件命名为balance.conf 内容如下： 12345678910111213141516upstream big_server_com &#123; server 127.0.0.3:8000 weight=5; server 127.0.0.3:8001 weight=5; server 192.168.0.1:8000; server 192.168.0.1:8001; &#125; server &#123; # simple load balancing listen 80; server_name big.server.com; access_log logs/big.server.access.log main; location / &#123; proxy_pass http://big_server_com; &#125; &#125; 代理服务器配置 在/etc/nginx/conf.d/目录下新建一个配置文件命名为proxy.conf 内容如下： 123456789101112131415161718192021222324252627proxy_redirect off;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;client_max_body_size 10m;client_body_buffer_size 128k;proxy_connect_timeout 90;proxy_send_timeout 90;proxy_read_timeout 90;proxy_buffers 32 4k;server &#123; # simple reverse-proxy listen 80; server_name domain2.com www.domain2.com; access_log logs/domain2.access.log main; # serve static files location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/big.server.com/htdocs; expires 30d; &#125; # pass requests for dynamic content to rails/turbogears/zope, et al location / &#123; proxy_pass http://127.0.0.1:8080; &#125; &#125; SSL/STL配置 123456789101112131415server &#123; listen 443 ssl; server_name qilezaitu.top www.qilezaitu.top; root /var/www/html; index index.html index.htm; ssl_certificate /etc/nginx/ssl/qilezaitu.top.pem; ssl_certificate_key /etc/nginx/ssl/qilezaitu.top.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; location / &#123; &#125;&#125; 强制http到https 12345server &#123; listen 80; server_name qilezaitu.top; rewrite ^(.*)$ https://qilezaitu.top permanent;&#125; 启动 启动Nginx只需要简单的输入 1nginx 当启动了nginx启动后，可以通过发送信号的方式管理你的nginx,如下： 1nginx -s signal 可用的signal： - stop:快速关闭 - quit:等待工作进程完成了当前的请求后关闭 - reload:重载配置 - reopen:刷新日志文件 将Nginx加入到自启动，在/etc/rc.d/rc.local文件中追加一行，如下： 1nginx 记录各种问题 总结 参考 Apache Vs NGINX – Which Is The Best Web Server for You? Nginx安装教程 Nginx Tutorial #1: Basic Concepts Understanding the Nginx Configuration File Structure and Configuration Contexts Alphabetical index of directives nginx.conf","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Cocos Creator 编辑器扩展","slug":"CocosCreator/CocosCreator编辑器扩展","date":"2019-11-04T16:00:00.000Z","updated":"2021-03-03T14:33:17.587Z","comments":true,"path":"2019/11/05/CocosCreator/CocosCreator编辑器扩展/","link":"","permalink":"http://yoursite.com/2019/11/05/CocosCreator/CocosCreator%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95/","excerpt":"前言 扩展编辑可以对我们的工作效率进行提高将通用的功能分装成一个包以备不同项目之间进行复用。","text":"前言 扩展编辑可以对我们的工作效率进行提高将通用的功能分装成一个包以备不同项目之间进行复用。 编辑器扩展初识 我们先来看看一个简单编辑器功能是如何构建的。 原理介绍 示例","categories":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/categories/CocosCreator/"}],"tags":[]}],"categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"},{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"工具/Hexo","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Hexo/"},{"name":"数学物理","slug":"数学物理","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"寻路算法","slug":"游戏/寻路算法","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Docker","slug":"服务器/Docker","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"数据库/Mysql","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/categories/CocosCreator/"}],"tags":[{"name":"协程","slug":"协程","permalink":"http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":".Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Mathjax","slug":"Mathjax","permalink":"http://yoursite.com/tags/Mathjax/"},{"name":"动画系统","slug":"动画系统","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"},{"name":"Dokcer","slug":"Dokcer","permalink":"http://yoursite.com/tags/Dokcer/"},{"name":"网络配置","slug":"网络配置","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"},{"name":"服务器工具","slug":"服务器工具","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B7%A5%E5%85%B7/"},{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]}