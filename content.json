{"meta":{"title":"张卫的博客","subtitle":"Done is better than perfect","description":null,"author":"张卫","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-07-18T07:18:33.000Z","updated":"2021-03-03T14:33:17.603Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"学习之地"},{"title":"分类","date":"2019-11-24T10:04:14.000Z","updated":"2021-03-03T14:33:17.604Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-24T06:58:16.000Z","updated":"2021-03-03T14:33:17.623Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"骨骼动画","slug":"Unity/骨骼动画","date":"2021-03-22T13:20:49.000Z","updated":"2021-03-28T14:37:29.516Z","comments":true,"path":"2021/03/22/Unity/骨骼动画/","link":"","permalink":"http://yoursite.com/2021/03/22/Unity/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/","excerpt":"\b本文主要基于Blender创建一个简单的机器人，并基于此机器人来了解骨骼动画的制作流程。制作骨骼动画主要包含以下步骤： 建模 构建骨骼 蒙皮和权重绘制 动画制作","text":"\b本文主要基于Blender创建一个简单的机器人，并基于此机器人来了解骨骼动画的制作流程。制作骨骼动画主要包含以下步骤： 建模 构建骨骼 蒙皮和权重绘制 动画制作 建模 \b建模就是通过最基础的几何图元点，线，面构建出各种不同形状的模型。构建好的机器人，如下图： 构建骨骼 模型建好后就可以开始构建Skeleton(骨骼)了，在构建Skeleton之前先来了解一下Bone(骨头)和Joint(关节)，其实和人体结构一样骨架也是由骨头和关节组成的有关节的地方就可以旋转，由大臂带动小臂也就是说小臂是大臂的一个子骨头，当大臂旋转时小臂也会跟着旋转。 蒙皮与权重绘制 现在骨骼构建好了，但是骨骼的旋转并没有带动模型顶点的改变，接下来要做的就是对骨骼进行蒙皮，蒙皮就是将模型的顶点附着到骨头上，也就是会记录受这个骨头所影响的顶点在这个骨头空间下的坐标位置。像关节这些地方的一个顶点可能会受多个骨骼影响所以每个顶点上还要记录每个顶点在每个骨骼下的权重，如果自动计算的权重不能满足那就需要手动绘制权重。当蒙皮和权重绘制好了，我们就可以通过骨骼的运动(主要是旋转)来带动顶点的运行。 顶点的位置计算过程大致如下： 通过父子骨骼之间的变换矩阵，计算出最终在世界坐标下的变换矩阵。 再将骨骼空间下顶点的坐标点乘以第一步计算出来的变换矩阵就计算出了顶点的世界坐标。 每个顶点的最终位置还得根据影响这个顶点的骨骼进行混合。 创建动画 骨骼和顶点绑定后，就只需要创建动画驱动骨骼进行运动，骨骼的运动又会带动骨骼关联的顶点进行运动，这样便形成了完整的动画。动画文件只需要记录每个关键帧骨骼的位置，旋转和缩放就能通过插值算法计算出平滑的动画。 参考 Beginner Blender Tutorial: How to Model &amp; Animate a Robot","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"Unity序列帧动画","slug":"Unity/Unity序列帧动画","date":"2021-03-21T10:04:00.000Z","updated":"2021-03-21T10:13:27.710Z","comments":true,"path":"2021/03/21/Unity/Unity序列帧动画/","link":"","permalink":"http://yoursite.com/2021/03/21/Unity/Unity%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB/","excerpt":"Unity实现序列帧动画主要有两种方式，一个是通过Unity自带的Animation进行制作，二是根据序列帧动画原理通过代码按固定帧率切换显示的图片即可实现序列帧动画效果。","text":"Unity实现序列帧动画主要有两种方式，一个是通过Unity自带的Animation进行制作，二是根据序列帧动画原理通过代码按固定帧率切换显示的图片即可实现序列帧动画效果。 资源导入 序列帧图片资源可以是单帧的图片也可以将所有的序列帧图片放到一张图片上 导入到Unity工程后通过SpriteEditor进行拆分 使用Animation实现 将拆分后的SpriteFrame选中后拖入到Hierarchy窗口，如下图： 代码实现 参见： GitHub 总结 在Unity里实现序列帧动画基本上就上述两种方式， 第一种方式 优点： 完全使用的是Unity的动画系统工作流程统一； 缺点： 只能使用SpriteRender进行渲染，如果要用UI的Image或RawImage进行渲染则动画需要手动在Animation里Key帧（也可以写工具自动Key帧） 只能使用Animator不能是用Animation组件（不知道是不是bug，本机系统mac os Unity版本2019.3.4f）即使将动画改为老版的模式也不行 第二种方式 优点： 更灵活可以使用所有渲染组件 缺点： 每一帧都需要手动指定，当然可以通过规定命名规则通过工具自动完成","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"动画介绍","slug":"Unity/动画介绍","date":"2021-03-21T09:52:28.000Z","updated":"2021-03-21T10:01:01.152Z","comments":true,"path":"2021/03/21/Unity/动画介绍/","link":"","permalink":"http://yoursite.com/2021/03/21/Unity/%E5%8A%A8%E7%94%BB%E4%BB%8B%E7%BB%8D/","excerpt":"介绍 传统动画(序列帧动画)是一种动画技术，其技术原理是通过人眼的视觉残留让连续的动作图片按一定的速度（帧率，帧/每秒）一帧一帧的切换使其产生连续的动画。在早期，动画的每帧都是手工绘制的，工作量巨大。在计算机动画出现之前，该技术是电影中动画的主要形式。计算机出现之后，随着CG行业技术的发展，人们可以在电脑上进行绘画并进行数字化的存在，但是并没有解决一帧帧的绘制问题。随着技术的不断发展随后便现了基于关键帧和插值技术的运动图形动画和骨骼动画等。","text":"介绍 传统动画(序列帧动画)是一种动画技术，其技术原理是通过人眼的视觉残留让连续的动作图片按一定的速度（帧率，帧/每秒）一帧一帧的切换使其产生连续的动画。在早期，动画的每帧都是手工绘制的，工作量巨大。在计算机动画出现之前，该技术是电影中动画的主要形式。计算机出现之后，随着CG行业技术的发展，人们可以在电脑上进行绘画并进行数字化的存在，但是并没有解决一帧帧的绘制问题。随着技术的不断发展随后便现了基于关键帧和插值技术的运动图形动画和骨骼动画等。 序列帧动画 序列帧动画就是按一定帧率播放的一帧一帧的图片。序列帧的制作方式一般分为两种: 一帧一帧的画 通过3转2的方式，即将3D模型渲染成一张张的图片 运动图形动画 运动图形动画是通过关键帧和插值技术，将图形进行位置，旋转和缩放的改变来达到动画的效果，比如像AE里将Logo或文字飞入等动画，主要用于广告投放素材，片头制作，多媒体相关行业，在游戏中也有很多这样的动画，比如UI动画也是属于运动图形动画。 骨骼动画 骨骼动画是通过关键帧和插值技术，将骨骼进行位置，旋转和缩放的变换，骨骼又带动顶点的变化，具体的变换原理会写一篇单独的文章进行介绍。 总结 其实动画就两种一种是序列帧动画，另一种是关键帧动画，现在主流的还是基于关键帧技术的动画，关键帧动画可以很大程度上的提升制作效率。 参考文献 The Different Types of Animation 5 Types Of Animation: Finding Inspiration In All Styles 动画发展史","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"Unity协程","slug":"Unity/Unity协程","date":"2021-03-17T04:13:25.000Z","updated":"2021-03-20T10:40:12.165Z","comments":true,"path":"2021/03/17/Unity/Unity协程/","link":"","permalink":"http://yoursite.com/2021/03/17/Unity/Unity%E5%8D%8F%E7%A8%8B/","excerpt":"为什么要使用协程 为什么要使用协程？，先来看段代码： 123456789101112131415161718192021222324252627using System.Collections;using UnityEngine;public class TestCoroutine : MonoBehaviour&#123; void Start() &#123; StartCoroutine(CoroutineFunc()); &#125; IEnumerator CoroutineFunc() &#123; var wfeof = new WaitForEndOfFrame() //1000次循环大概1s for(int i = 0; i &lt; 1000; i++) &#123; //假设做大量的工作,大概CPU耗时:0.1s DoManyWork(); yield return wfeof; &#125; &#125; void DoManyWork() &#123; Debug.Log(\"DoManyWork is called.\"); &#125;&#125; 上面的CoroutineFunc函数里面消耗了大量的CPU时间，在没有协程的开发环境中，比如像C/C++这样的开发语言，一般会创建一个线程来执行这种耗时的操作，多线程开发也会牵扯到各种数据和资源的互斥访问和线程同步的问题，这也导致在其他线程访问Unity引擎相关的组件会出现问题，因为我们没法控制其他的线程在访问操作一个对象时Unity引擎不去访问它，所以在Unity中其他线程一旦访问Unity引擎相关的组件就可能回出错。因此为让Unity的主线程不被这种耗时的操作给卡住，就只有将这种耗时的操作分到多帧里去执行，所以就出现了这种伪线程即协程。","text":"为什么要使用协程 为什么要使用协程？，先来看段代码： 123456789101112131415161718192021222324252627using System.Collections;using UnityEngine;public class TestCoroutine : MonoBehaviour&#123; void Start() &#123; StartCoroutine(CoroutineFunc()); &#125; IEnumerator CoroutineFunc() &#123; var wfeof = new WaitForEndOfFrame() //1000次循环大概1s for(int i = 0; i &lt; 1000; i++) &#123; //假设做大量的工作,大概CPU耗时:0.1s DoManyWork(); yield return wfeof; &#125; &#125; void DoManyWork() &#123; Debug.Log(\"DoManyWork is called.\"); &#125;&#125; 上面的CoroutineFunc函数里面消耗了大量的CPU时间，在没有协程的开发环境中，比如像C/C++这样的开发语言，一般会创建一个线程来执行这种耗时的操作，多线程开发也会牵扯到各种数据和资源的互斥访问和线程同步的问题，这也导致在其他线程访问Unity引擎相关的组件会出现问题，因为我们没法控制其他的线程在访问操作一个对象时Unity引擎不去访问它，所以在Unity中其他线程一旦访问Unity引擎相关的组件就可能回出错。因此为让Unity的主线程不被这种耗时的操作给卡住，就只有将这种耗时的操作分到多帧里去执行，所以就出现了这种伪线程即协程。 上面实例代码中for循环的控制变量i，在下次调用的时候是如何保证能正常迭代的？为什么函数签名中的返回值必须是IEnumerator，可以是其他的吗？协程函数又是谁在调？WaitForEndOfFrame又是什么，可以有其他的吗，可以自定义吗？yield return又是什么呢？ 协程实现原理 yield return生成器功能 yield return是NET 2.0框架允许C＃引入一个提供生成器功能的迭代器，主要是构建类似于python中的yield的功能。使用yield return,下面的这个函数将自动的保存迭代中的状态。代码如下： 12345678910111213141516171819// 这个方法将传入一个数组// 并且返回所有even的数字namespace DotnetExample&#123; class Program &#123; public static IEnumerable&lt;int&gt; GetEven(int[] numbers) &#123; for(int i=0; i &lt; numbers.Length; i++) &#123; if (i % 2 == 0) yield return numbers[i]; &#125; &#125; static void Main(string[] args) &#123; &#125; &#125;&#125; 这里也有一个yield break声明，此语句用于无条件返回到调用者。在每个生成器方法的最后都会有一个隐式的yield break。前面我们提到了几个陌生的名词：生成器功能，迭代器和生成器方法。先不管这些晦涩的术语，我们先来看哈上面这段代码对应的IL代码，删除了一些不影响我们理解功能的代码，删除后的结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// 生成了一个名为：&lt;GetEven&gt;d__0的类，并继承了IEnumerable和IEnumerator接口.class nested private auto ansi sealed beforefieldinit &lt;GetEven&gt;d__0 extends [System.Runtime]System.Object implements [System.Runtime]System.Collections.Generic.IEnumerable`1&lt;System.Int32&gt;, [System.Runtime]System.Collections.IEnumerable, [System.Runtime]System.Collections.Generic.IEnumerator`1&lt;System.Int32&gt;, [System.Runtime]System.Collections.IEnumerator, [System.Runtime]System.IDisposable&#123; .field private int32 '&lt;&gt;1__state' //用于保存迭代状态(光标位置) .field private int32 '&lt;&gt;2__current' //记录当前的迭代值 .field private int32 '&lt;&gt;l__initialThreadId' //记录执行的线程ID .field private int32[] numbers //记录的传入的形参numbers .field public int32[] '&lt;&gt;3__numbers' //记录的传入的形参numbers，给外部访问的 .field private int32 '&lt;i&gt;5__1' //记录的循环控制变量i //每迭代一次调用一下，将光标下移一个 .method private hidebysig newslot virtual final instance default bool MoveNext() cil managed &#123; .maxstack 3 .locals init(int32 V_0, bool V_1, int32 V_2, bool V_3) IL_0000: ldarg.0 IL_0001: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;1__state' IL_0006: stloc.0 IL_0007: ldloc.0 IL_0008: brfalse.s IL_0012 IL_000a: br.s IL_000c IL_000c: ldloc.0 IL_000d: ldc.i4.1 IL_000e: beq.s IL_0014 IL_0010: br.s IL_0016 IL_0012: br.s IL_0018 IL_0014: br.s IL_004e IL_0016: ldc.i4.0 IL_0017: ret IL_0018: ldarg.0 IL_0019: ldc.i4.m1 IL_001a: stfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;1__state' IL_001f: nop IL_0020: ldarg.0 IL_0021: ldc.i4.0 IL_0022: stfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;i&gt;5__1' IL_0027: br.s IL_0066 IL_0029: nop IL_002a: ldarg.0 IL_002b: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;i&gt;5__1' IL_0030: ldc.i4.2 IL_0031: rem IL_0032: ldc.i4.0 IL_0033: ceq IL_0035: stloc.1 IL_0036: ldloc.1 IL_0037: brfalse.s IL_0055 IL_0039: ldarg.0 IL_003a: ldarg.0 IL_003b: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;i&gt;5__1' IL_0040: stfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;2__current' IL_0045: ldarg.0 IL_0046: ldc.i4.1 IL_0047: stfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;1__state' IL_004c: ldc.i4.1 IL_004d: ret IL_004e: ldarg.0 IL_004f: ldc.i4.m1 IL_0050: stfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;1__state' IL_0055: nop IL_0056: ldarg.0 IL_0057: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;i&gt;5__1' IL_005c: stloc.2 IL_005d: ldarg.0 IL_005e: ldloc.2 IL_005f: ldc.i4.1 IL_0060: add IL_0061: stfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;i&gt;5__1' IL_0066: ldarg.0 IL_0067: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;i&gt;5__1' IL_006c: ldarg.0 IL_006d: ldfld int32[] DotnetExample.Program/&lt;GetEven&gt;d__0::numbers IL_0072: ldlen IL_0073: conv.i4 IL_0074: clt IL_0076: stloc.3 IL_0077: ldloc.3 IL_0078: brtrue.s IL_0029 IL_007a: ldc.i4.0 IL_007b: ret &#125; // End of method System.Boolean DotnetExample.Program/&lt;GetEven&gt;d__0::MoveNext() //获取当前的迭代值，内部函数，外部调用Current(),Current函数调用的就是这个函数 .method private hidebysig newslot virtual specialname final instance default int32 System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.get_Current() cil managed &#123; .custom instance void class [System.Runtime]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) // .... // Method begins at Relative Virtual Address (RVA) 0x2114 // Code size 7 (0x7) .maxstack 8 IL_0000: ldarg.0 IL_0001: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;2__current' IL_0006: ret &#125; // End of method System.Int32 DotnetExample.Program/&lt;GetEven&gt;d__0::System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.get_Current() //实现IEnumerable的GetEnumerator()，用于获取Enumerator对象，并初始化了迭代状态&lt;&gt;1__state和设置numbers形参数据 .method private hidebysig newslot virtual final instance default [System.Runtime]System.Collections.Generic.IEnumerator`1&lt;System.Int32&gt; System.Collections.Generic.IEnumerable&lt;System.Int32&gt;.GetEnumerator() cil managed &#123; .maxstack 2 .locals init(class DotnetExample.Program/&lt;GetEven&gt;d__0 V_0) IL_0000: ldarg.0 IL_0001: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;1__state' IL_0006: ldc.i4.s -2 IL_0008: bne.un.s IL_0022 IL_000a: ldarg.0 IL_000b: ldfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;l__initialThreadId' IL_0010: call int32 class [System.Runtime]System.Environment::get_CurrentManagedThreadId() IL_0015: bne.un.s IL_0022 IL_0017: ldarg.0 IL_0018: ldc.i4.0 IL_0019: stfld int32 DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;1__state' IL_001e: ldarg.0 IL_001f: stloc.0 IL_0020: br.s IL_0029 IL_0022: ldc.i4.0 IL_0023: newobj instance void class DotnetExample.Program/&lt;GetEven&gt;d__0::.ctor(int32) IL_0028: stloc.0 IL_0029: ldloc.0 IL_002a: ldarg.0 IL_002b: ldfld int32[] DotnetExample.Program/&lt;GetEven&gt;d__0::'&lt;&gt;3__numbers' IL_0030: stfld int32[] DotnetExample.Program/&lt;GetEven&gt;d__0::numbers IL_0035: ldloc.0 IL_0036: ret &#125; // End of method System.Collections.Generic.IEnumerator`1&lt;System.Int32&gt; DotnetExample.Program/&lt;GetEven&gt;d__0::System.Collections.Generic.IEnumerable&lt;System.Int32&gt;.GetEnumerator() // 获取当前的迭代对象 .property instance int32 System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.Current () &#123; .get instance default int32 DotnetExample.Program/&lt;GetEven&gt;d__0::System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.get_Current () &#125; // End of property System.Int32 DotnetExample.Program/&lt;GetEven&gt;d__0::System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.Current()&#125; // End of class DotnetExample.Program/&lt;GetEven&gt;d__0 从IL代码我们可以看出，当我们使用yield return关键字时，C#编译器会为我们生成一个实现了IEnumerable和IEnumerator接口的类，这就是生成器，生成的类中又保存了迭代状态，所以也具有迭代功能，整个函数就是生成器方法。那么我们现在就可以可以使用foreach进行遍历了，代码如下： 123456789101112static void Main(string[] args)&#123; var iterator = GetEven(new int[4] &#123; 1, 2, 3, 4 &#125;); foreach (var item in iterator) &#123; Console.WriteLine($\"Item:&#123;item&#125;\"); &#125;&#125;//将输出Item:1Item:3 IEnumerator有什么呢？ IEnumerable和IEnumerator的区别 还是先来看一个实例，如下： 12345678public static IEnumerator&lt;int&gt; GetEven(int[] numbers)&#123; for (int i = 0; i &lt; numbers.Length; i++) &#123; if (i % 2 == 0) yield return numbers[i]; &#125;&#125; 这实例代码跟上个实例的代码除了将IEnumerable改变成了IEnumerator以外其他的没有任何差别，那么来看哈IL有什么差别，删除了函数体的IL代码如下： 123456789101112131415161718192021222324// 只实现了IEnumerator接口，所有没有GetEnumerator函数.class nested private auto ansi sealed beforefieldinit &lt;GetEven&gt;d__0 extends [System.Runtime]System.Object implements [System.Runtime]System.Collections.Generic.IEnumerator`1&lt;System.Int32&gt;, [System.Runtime]System.Collections.IEnumerator, [System.Runtime]System.IDisposable&#123; .field private int32 '&lt;&gt;1__state' //用于保存迭代状态(光标位置) .field private int32 '&lt;&gt;2__current' //记录当前的迭代值 .field public int32[] numbers //记录的传入的形参numbers .field private int32 '&lt;i&gt;5__1' //记录的循环控制变量i .method public hidebysig specialname rtspecialname instance default void .ctor(int32 &lt;&gt;1__state) cil managed &#123; &#125; .method private hidebysig newslot virtual final instance default bool MoveNext() cil managed &#123; &#125; .method private hidebysig newslot virtual specialname final instance default int32 System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.get_Current() cil managed &#123; &#125; .property instance int32 System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.Current () &#123; .get instance default int32 DotnetExample.Program/&lt;GetEven&gt;d__0::System.Collections.Generic.IEnumerator&lt;System.Int32&gt;.get_Current () &#125; &#125; 那么返回IEnumerator的迭代器，将如何遍历呢？尝试用foreach遍历但编译器提示： “ CS1579: foreach statement cannot operate on variables of type 'IEnumerator' because 'IEnumerator' does not contain a public instance or extension definition for 'GetEnumerator'” 所以编译限定了能使用foreach遍历的对象必须有GetEnumerator函数，因为IEnumerator没有实现IEnumerable接口的GetEnumerator方法，所有foreach是不能遍历。但是foreach内部也是通过IEnumerator提供的接口来进行遍历的，那么我们尝试手动调用IEnumerator提供的函数来进行遍历，代码如下： 123456789101112static void Main(string[] args)&#123; var iterator = GetEven(new int[4] &#123; 1, 2, 3, 4 &#125;); while (iterator.MoveNext()) &#123; Console.WriteLine($\"Item:&#123;iterator.Current&#125;\"); &#125;&#125;//将输出Item:1Item:3 IEnumerable和IEnumerator都会生成IEnumerator里面的接口函数, 也就是说IEnumerable能够实现IEnumerator接口定义的全部功能，而IEnumerable只有一个GetEnumerator函数，这个函数只是为了给foreach提供支持，foreach对应的IL代码也会调用GetEnumerator函数来获取一个初始化了状态的Enumerator对象，最终的迭代器也是由Enumerator接口提供的支持。 从上面的分析来看，在Unity里面定义协时，我们也可定义个返回IEnumerable的函数来实现协程的功能，代码如下： 12345IEnumerable CoroutineFunc()&#123; //TODO:功能 yield return&#125; 在启动协程的时候我们手动调动GetEnumerator()函数来获取一个Enumerator对象，代码如下： 1StartCoroutine(CoroutineFunc().GetEnumerator()); 为了验证我们的假设才这样调用的，项目中不要这样去调用，底层的IL\b代码会多一些。经过测试这样的调用方式也是没有问题。 谁在调用 前面我们手动调用了Enumerator接口的MoveNext来进行迭代，那在Unity的协程中又是谁在负责调用MoveNext呢？下面聊聊\b协程的生命周期。先来看哈Unity的脚本函数生命周期图，如下： 在上图中，我们可以看出所有类型的协程都是在对象的生命周期的不同阶段执行的，从图中可以看出，主要在3个阶段执行： 1. 在物理更新完成调用注册的yield WaitForFixedUpdate协程。 2. 在游戏逻辑更新中调用注册的yield null, yield WaitForSeconds,yield WWW, yield StartCoroutine和自定义的其他的协程。 3. 在一帧结束时调用注册的yield WaitForEndOfFrame 当Unity引擎在执行每个对象对应的生命周期阶段时，都会调用生成的协程类的MoveNext函数进行下一步，如此反复直到MoveNext返回false,此时这个协程的生命周期也就结束了。如果我们想提前结束一个协程的生命周期呢?我们可以调用StopCoroutine函数来注销正在执行的协程，注销后就会从协程队列里面移除，在下次生命周期到来时便不会被执行了。 像WWW,WaitForSecondsRealtime, WaitUntil,WaitWhile这些继承至CustomYieldInstruction的Enumerator对象都是在游戏逻辑更新中检查执行的，这些“自定义”类型的协程对象不会直接调用MoveNext而是先检查keepWaiting是否为false如果为false则在这次的生命周期中调用MoveNext函数。伪代码如下： 1234567891011Update()&#123; List&lt;Enumerator&gt; coroutineList = ... foreach(var cr in coroutineList) &#123; var cyi = cr as CustomYieldInstruction if(cyi &amp;&amp; !cyi.keepWaiting)&#123; cyi.MoveNext() &#125; &#125;&#125; 理解了Unity调用协程机制后，我们来自定义个每间隔指定帧数的yield对象。代码如下： 1234567891011121314151617181920212223242526public class IntervalFrame : CustomYieldInstruction&#123; private int _curFrameCount = 0; private int _frameCount = 0; public IntervalFrame(int count) &#123; _frameCount = count; &#125; public override bool keepWaiting &#123; get &#123; _curFrameCount++; if (_curFrameCount &lt; _frameCount) &#123; return true; &#125; else &#123; _curFrameCount = 0; return false; &#125; &#125; &#125; &#125; 在写自定义yield对象时，注意重置自己内部状态，这样在使用时就不用每次都new一个新的对象了。Unity内建的yield类型都是重置了状态的。上面这个实例在keepWaiting返回false的时候重置了_curFrameCount内部字段的。 参考 C# 2.0 IEnumerable VS IEnumerator in C# Order of execution for event functions","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"协程","slug":"协程","permalink":"http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"委托与事件","slug":"编程语言/CSharp/委托与事件","date":"2021-03-14T10:16:09.000Z","updated":"2021-03-17T15:45:16.997Z","comments":true,"path":"2021/03/14/编程语言/CSharp/委托与事件/","link":"","permalink":"http://yoursite.com/2021/03/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/","excerpt":"委托 什么是委托？委托与事件有什么关系呢？先来看一下委托的定义，代码如下： 12345678910111213namespace DotnetExample&#123; //定义一个委托 public delegate void VoidCallback(); // Console必须要一个Main函数才能编译通过 class Program &#123; static void Main(string[] args) &#123; &#125; &#125;&#125;","text":"委托 什么是委托？委托与事件有什么关系呢？先来看一下委托的定义，代码如下： 12345678910111213namespace DotnetExample&#123; //定义一个委托 public delegate void VoidCallback(); // Console必须要一个Main函数才能编译通过 class Program &#123; static void Main(string[] args) &#123; &#125; &#125;&#125; 这样的就定义了一个返回值和参数都为空的委托，这个委托究竟是什么呢，先别急，我来看哈，这个委托转换成CIL是什么样的，CIL代码如下： 123456789101112131415.class public auto ansi sealed DotnetExample.VoidCallback extends [System.Runtime]System.MulticastDelegate&#123; .method public hidebysig specialname rtspecialname instance default void .ctor([System.Runtime]System.Object 'object', native int 'method') runtime managed &#123; &#125; // End of method System.Void DotnetExample.VoidCallback::.ctor(System.Object,System.IntPtr) .method public hidebysig newslot virtual instance default void Invoke() runtime managed &#123; &#125; // End of method System.Void DotnetExample.VoidCallback::Invoke() .method public hidebysig newslot virtual instance default [System.Runtime]System.IAsyncResult BeginInvoke(class [System.Runtime]System.AsyncCallback callback, [System.Runtime]System.Object 'object') runtime managed &#123; &#125; // End of method System.IAsyncResult DotnetExample.VoidCallback::BeginInvoke(System.AsyncCallback,System.Object) .method public hidebysig newslot virtual instance default void EndInvoke(class [System.Runtime]System.IAsyncResult result) runtime managed &#123; &#125; // End of method System.Void DotnetExample.VoidCallback::EndInvoke(System.IAsyncResult)&#125; // End of class DotnetExample.VoidCallback 现在我们明白了原来委托就是一个继承至System.MulticastDelegate的类，delegate关键字就是一个语法糖而已。MulticastDelegate类又继承至Delegate。看看Delegate都有哪些内容，如下图： 其中重要的几个函数： 构造函数 .ctor(Type, String), .ctor(Object String)，当更一个委托赋值(=)时，会根据方法类型选择调用哪个构造函数，静态的函数调用第一种形式的构造函数，如果是成员函数的则会调用第二种形式的构造函数 Combine函数， 当使用+=的时候则会调动Combine将一个委托追加到调用链的后面。 CreateDelegate静态函数，更具各种类型创建委托 GetInvocationList函数，获取委托链上的说有委托 Remove函数，当使用-=的时候回调用Remove函数，它跟Combine函数是一对的，一个负责添加委托，一个负责移除委托。 上面定义了一个VoidCallback委托，下面我们来使用一下这个委托，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738namespace DotnetExample&#123; class Program &#123; static void Main(string[] args) &#123; new DelegateExample().Init(); &#125; &#125; public delegate void VoidCallback(); class DelegateExample &#123; public VoidCallback voidCallback; public void Init() &#123; voidCallback = TestCallback; voidCallback += TestStaticCallback; voidCallback.Invoke(); voidCallback -= TestCallback; voidCallback -= TestStaticCallback; &#125; void TestCallback() &#123; Console.WriteLine(\"TestCallback is called.\"); &#125; static void TestStaticCallback() &#123; Console.WriteLine(\"TestStaticCallback is called.\"); &#125; &#125;&#125; 上面这些函数都是Delegate类里面的功能函数，其中“=”运算换转换成构造函数，“+=”会转换成Combine函数，“-=”会被转换成Remove函数。那么Invoke函数是哪里来的呢？在上面我们定义了一个委托，编译后给我们生成了一个类，这个类里面包含了3个函数其中一个就是Invoke,还是两个是BeginInvoke和EndInvoke函数，这几个函数有什么区别呢？Invoke是同步函数在主线程执行而BeginInvoke和EndInvoke是用于异步调用的一对函数在其他线程运行。BeginInvoke和EndInvoke如何使用,可以参考https://www.cnblogs.com/canger/p/5938591.html。 事件 我们还是通过CIL来了解事件吧！先定义个事件看看转换后的CIL代码是什么样的，事件定义代码如下： 12345678910111213namespace DotnetExample&#123; public delegate void VoidCallback(); class Program &#123; public static event VoidCallback eventFields; static void Main(string[] args) &#123; &#125; &#125;&#125; 删除了无关代码后，IL代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566.class private auto ansi beforefieldinit DotnetExample.Program extends [System.Runtime]System.Object&#123; // eventFields这个字段被转换成里private的访问权限 .field private static class DotnetExample.VoidCallback eventFields // 生成了一个add_xxxx(字段名)的函数 .method public hidebysig specialname static default void add_eventFields(class DotnetExample.VoidCallback 'value') cil managed &#123; // Method begins at Relative Virtual Address (RVA) 0x2050 // Code size 39 (0x27) .maxstack 3 .locals init(class DotnetExample.VoidCallback V_0, class DotnetExample.VoidCallback V_1, class DotnetExample.VoidCallback V_2) IL_0000: ldsfld class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_0005: stloc.0 IL_0006: ldloc.0 IL_0007: stloc.1 IL_0008: ldloc.1 IL_0009: ldarg.0 IL_000a: call [System.Runtime]System.Delegate class [System.Runtime]System.Delegate::Combine([System.Runtime]System.Delegate, [System.Runtime]System.Delegate) IL_000f: castclass class DotnetExample.VoidCallback IL_0014: stloc.2 IL_0015: ldsflda class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_001a: ldloc.2 IL_001b: ldloc.1 IL_001c: call !!0 class [System.Threading]System.Threading.Interlocked::CompareExchange&lt;class DotnetExample.VoidCallback&gt;(!!0&amp;, !!0, !!0) IL_0021: stloc.0 IL_0022: ldloc.0 IL_0023: ldloc.1 IL_0024: bne.un.s IL_0006 IL_0026: ret &#125; // End of method System.Void DotnetExample.Program::add_eventFields(DotnetExample.VoidCallback) // 生成了一个remove_xxxx(字段名)的函数 .method public hidebysig specialname static default void remove_eventFields(class DotnetExample.VoidCallback 'value') cil managed &#123; // Method begins at Relative Virtual Address (RVA) 0x2084 // Code size 39 (0x27) .maxstack 3 .locals init(class DotnetExample.VoidCallback V_0, class DotnetExample.VoidCallback V_1, class DotnetExample.VoidCallback V_2) IL_0000: ldsfld class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_0005: stloc.0 IL_0006: ldloc.0 IL_0007: stloc.1 IL_0008: ldloc.1 IL_0009: ldarg.0 IL_000a: call [System.Runtime]System.Delegate class [System.Runtime]System.Delegate::Remove([System.Runtime]System.Delegate, [System.Runtime]System.Delegate) IL_000f: castclass class DotnetExample.VoidCallback IL_0014: stloc.2 IL_0015: ldsflda class DotnetExample.VoidCallback DotnetExample.Program::eventFields IL_001a: ldloc.2 IL_001b: ldloc.1 IL_001c: call !!0 class [System.Threading]System.Threading.Interlocked::CompareExchange&lt;class DotnetExample.VoidCallback&gt;(!!0&amp;, !!0, !!0) IL_0021: stloc.0 IL_0022: ldloc.0 IL_0023: ldloc.1 IL_0024: bne.un.s IL_0006 IL_0026: ret &#125; // End of method System.Void DotnetExample.Program::remove_eventFields(DotnetExample.VoidCallback) // eventFields事件定义了+= addon 和-= removeon两个函数 .event class DotnetExample.VoidCallback eventFields &#123; .addon default void DotnetExample.Program::add_eventFields (class DotnetExample.VoidCallback 'value') .removeon default void DotnetExample.Program::remove_eventFields (class DotnetExample.VoidCallback 'value') &#125; // End of property DotnetExample.VoidCallback DotnetExample.Program::eventFields&#125; // End of class DotnetExample.Program 根据IL代码发现，我们定义的public的事件字段eventFields被转换成了private的访问权限，并且eventFields也就是只是委托类型的对象，还生成了两个public的函数add_xxxx和remove_xxxx函数，add_xxxx函数里直接调用了委托的Combine函数，remove_xxxx函数了调用了委托的Remove函数，以及一个event类型，里面包含了两个函数分别对应+=和-=两个运算符。 委托与事件的区别 根据上两节的分析，总结委托与事件的区别。 相同点 事件本质也是委托 不同点 事件访问权限都是private的，要触发事件调用只能在类的内部。 在外部，事件只能通过+=或-=进行回调函数的添加或删除","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"聊聊.Net开发平台","slug":"编程语言/CSharp/聊聊.Net开发平台","date":"2021-03-04T09:30:21.000Z","updated":"2021-03-17T15:42:10.814Z","comments":true,"path":"2021/03/04/编程语言/CSharp/聊聊.Net开发平台/","link":"","permalink":"http://yoursite.com/2021/03/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/%E8%81%8A%E8%81%8A.Net%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/","excerpt":"介绍 .Net是什么呢？.Net是1998年微软剑桥研究院的技术人员研究的下一代开发技术，并将其制定的规范(CLI)提交到了ECMA，形成了ECMA335规范, 随后被ISO采纳为国际标准ISO/IEC 23271:2012。到2002微软正式发布了.NET Framework 1.0。.NET Framework是.Net开发技术规范的第一个实现，所以在初期.Net和.Net Framework指的是同一个东西，但它们本质上是完全不同的。由于当时只有微软的.Net Framework实现了.Net标准所以也仅限于Windows开发栈。.Net Framework平台的内容包含很多组件和库，像WinForm, WebForm, WPF，Asp.net等。直到2004年Mono让其可以在Linux上运行了，慢慢的Mono也开始支持Android, iOS，MacOSx让.Net实现跨平台。","text":"介绍 .Net是什么呢？.Net是1998年微软剑桥研究院的技术人员研究的下一代开发技术，并将其制定的规范(CLI)提交到了ECMA，形成了ECMA335规范, 随后被ISO采纳为国际标准ISO/IEC 23271:2012。到2002微软正式发布了.NET Framework 1.0。.NET Framework是.Net开发技术规范的第一个实现，所以在初期.Net和.Net Framework指的是同一个东西，但它们本质上是完全不同的。由于当时只有微软的.Net Framework实现了.Net标准所以也仅限于Windows开发栈。.Net Framework平台的内容包含很多组件和库，像WinForm, WebForm, WPF，Asp.net等。直到2004年Mono让其可以在Linux上运行了，慢慢的Mono也开始支持Android, iOS，MacOSx让.Net实现跨平台。微软为了让.Net能够在多个平台上运行，在2014公布了.Net Core计划，并于2016年发布了第一个.Net开源版本.Net Core1.0该版本主要实现了Asp.net, 后陆续加入了WinForm和WPF的支持（仅在Windows平台下），意在将.Net Framework的功能移植成开源跨平台的版本，当然.Net Core 也是.Net的未来。为了快速的整合.Net的生态，微软在2016年收购了Xamarin（Mono）, 并将Xamarin的开发工具集整合到了Vistual Studio中，至此微软统一了.Net生态。\b\b废话说完，下面进入正题。聊一聊.Net中的相关概念和术语，相信大家也经见过一些，比如：CLI、CIL、CTS、CLS、CLR、JIT、BCL、FCL、Module、Assembly 等，本文不会安字典顺序来一一讲解，因为这样大家很难理解也很难记住，本文将通过大家熟悉的HelloWorld程序(基于.Net Core 5.0)来进行解释，欢迎主角登场！ HelloWorld粉墨登场 本文实例基于 .Net core 5.0运行，我们先来创建一个控制台工程命名为HelloWorld，命令如下： 1dotnet new console -o ./HelloWorld 创建完成后将创建如下目录结构，如下图： dotnet初始项目结构 HelloWorld.csproj 项目文件 Program.cs 默认入口代码Main函数 obj 临时文件 至此HelloWorld程序就完成了，代码如下： 12345678910111213// Program.csusing System;namespace HelloWorld&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(\"Hello World!\"); &#125; &#125;&#125; 这个代码虽然简单，就在控制台打印了一个“Hello World!”. 那这个Hello World有什么怎么被打印出来的呢？里面的Console.WriteLine有哪里来的呢？这个代码编译后会什么内容呢？会和C/C++编译出来的东西一样吗？这个代码又是如何运行起来的呢？这里面就要涉及到.Net规范的核心内容了，下面我们就通过这个Hello World程序来进行介绍。 在HelloWorld目录里，运行如下命令将HelloWorld程序编译出来，命令如下： 1dotnet build -c \"Release\" 编译后将生产一个HelloWorld.dll的文件, 此文件就是一个程序集(Assembly)。那么这个程序集的结构是什么样的呢？ Assembly Assembly包含了哪些内容呢？Assembly是一个自诉型程序集，主要有下面2类 Manifest 清单部分描述了Assembly自身的一些基础信息，包括版本信息，\b以及对模块和其他程序集的引用关系等；Assembly至少包含一个Module，Module又是代码(CIL)的集合。 元数据 元数据描述了程序集拥有哪些类型，类型的成员，以及成员的可见性等。 CIL代码，详细信息参见下一节 我们可以通过安装ILDASM工具来查看Assembly里的信息，命令如下： 安装 1dotnet tool install -g dotnet-ildasm 查看程序集 1dotnet ildasm HelloWorld.dll -o ./HelloWorld.il 我们先目睹一下HelloWorld Assembly里的Manifest信息： 12345678910111213141516171819202122232425262728293031323334.assembly extern System.Runtime&#123; .publickeytoken &#x3D; ( B0 3F 5F 7F 11 D5 0A 3A ) &#x2F;&#x2F; .._..... .ver 5:0:0:0&#125;.assembly extern System.Console&#123; .publickeytoken &#x3D; ( B0 3F 5F 7F 11 D5 0A 3A ) &#x2F;&#x2F; .._..... .ver 5:0:0:0&#125;.assembly &#39;HelloWorld&#39;&#123; .custom instance void class [System.Runtime]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) &#x3D; ( 01 00 08 00 00 00 00 00 ) &#x2F;&#x2F; ........ .custom instance void class [System.Runtime]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() &#x3D; ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78 63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 ) &#x2F;&#x2F; ....T..WrapNonExceptionThrows. .custom instance void class [System.Runtime]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) &#x3D; ( 01 00 18 2E 4E 45 54 43 6F 72 65 41 70 70 2C 56 65 72 73 69 6F 6E 3D 76 35 2E 30 01 00 54 0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C 61 79 4E 61 6D 65 00 ) &#x2F;&#x2F; ....NETCoreApp.Version.v5.0..T..FrameworkDisplayName. .custom instance void class [System.Runtime]System.Reflection.AssemblyCompanyAttribute::.ctor(string) &#x3D; ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 ) &#x2F;&#x2F; ...HelloWorld.. .custom instance void class [System.Runtime]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) &#x3D; ( 01 00 07 72 65 6C 65 61 73 65 00 00 ) &#x2F;&#x2F; ...release.. .custom instance void class [System.Runtime]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) &#x3D; ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 ) &#x2F;&#x2F; ...1.0.0.0.. .custom instance void class [System.Runtime]System.Reflection.AssemblyInformationalVersionAttribute::.ctor(string) &#x3D; ( 01 00 05 31 2E 30 2E 30 00 00 ) &#x2F;&#x2F; ...1.0.0.. .custom instance void class [System.Runtime]System.Reflection.AssemblyProductAttribute::.ctor(string) &#x3D; ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 ) &#x2F;&#x2F; ...HelloWorld.. .custom instance void class [System.Runtime]System.Reflection.AssemblyTitleAttribute::.ctor(string) &#x3D; ( 01 00 0A 48 65 6C 6C 6F 57 6F 72 6C 64 00 00 ) &#x2F;&#x2F; ...HelloWorld.. .hash algorithm 0x00008004 .ver 1:0:0:0&#125;.module &#39;HelloWorld.dll&#39;&#x2F;&#x2F; MVID: &#123;70604f0b-74ab-4028-87d6-2026571d0897&#125;.imagebase 0x00400000.file alignment 0x00000200.stackreserve 0x00100000.subsystem 0x0003 &#x2F;&#x2F; WindowsCui.corflags 0x00000001 &#x2F;&#x2F; ILOnly CIL——公共中间语言 C#编译器将C#代码编译成包含了CIL的程序集(Assembly),其他的编程语言比如VB,F#等,通过自己的编译器将源码编译成CIL，那些能够被编译成CIL的编程语言我们统称为面向.Net的语言，正因为有CIL中间语言的存在才使得.Net能够实现跨语言编程。 接下来我们看哈上面的C#的HelloWorld程序的CIL代码，如下： 12345678910111213141516171819202122.class private auto ansi beforefieldinit HelloWorld.Program extends [System.Runtime]System.Object&#123; .method private hidebysig static default void Main(string[] args) cil managed &#123; &#x2F;&#x2F; Method begins at Relative Virtual Address (RVA) 0x2050 .entrypoint &#x2F;&#x2F; Code size 11 (0xB) .maxstack 8 IL_0000: ldstr &quot;Hello World!&quot; IL_0005: call void class [System.Console]System.Console::WriteLine(string) IL_000a: ret &#125; &#x2F;&#x2F; End of method System.Void HelloWorld.Program::Main(System.String[]) .method public hidebysig specialname rtspecialname instance default void .ctor() cil managed &#123; &#x2F;&#x2F; Method begins at Relative Virtual Address (RVA) 0x205C &#x2F;&#x2F; Code size 7 (0x7) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void class [System.Runtime]System.Object::.ctor() IL_0006: ret &#125; &#x2F;&#x2F; End of method System.Void HelloWorld.Program::.ctor()&#125; &#x2F;&#x2F; End of class HelloWorld.Program 下面我们来分析一下“公共中间语言”的“公共”，“中间”和“语言”都代表的什么 ### 公共 公共指的是通用的意思，也就是说不论你用哪种语言编写的代码最终编译出的都是通过CIL来描述的，我们新建一个VB的HelloWorld工程，命令如下： 1dotnet new console -lang VB -o ./HelloWorldVB VB代码如下： 1234567Imports SystemModule Program Sub Main(args As String()) Console.WriteLine(\"Hello World!\") End SubEnd Module 编译后将HelloWorldVB.dll通过ildasm工具反编译成CIL,代码如下： 123456789101112131415.class private auto ansi sealed HelloWorldVB.Program extends [System.Runtime]System.Object&#123; .custom instance void class [Microsoft.VisualBasic.Core]Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute::.ctor() &#x3D; ( 01 00 00 00 ) &#x2F;&#x2F; .... .method public static default void Main(string[] args) cil managed &#123; .custom instance void class [System.Runtime]System.STAThreadAttribute::.ctor() &#x3D; ( 01 00 00 00 ) &#x2F;&#x2F; .... &#x2F;&#x2F; Method begins at Relative Virtual Address (RVA) 0x2050 .entrypoint &#x2F;&#x2F; Code size 11 (0xB) .maxstack 8 IL_0000: ldstr &quot;Hello World!&quot; IL_0005: call void class [System.Console]System.Console::WriteLine(string) IL_000a: ret &#125; &#x2F;&#x2F; End of method System.Void HelloWorldVB.Program::Main(System.String[])&#125; &#x2F;&#x2F; End of class HelloWorldVB.Program 可以看出C#和VB编译出来的CIL代码基本上一样只是C#多生成了一个类的构造函数。因为VB是面向过程的编程所以不存在类和类的构造函数这一说。现在我们应该明白公共代表什么意思了吧！ 中间 为什么是“中间”呢？CIL不像C/C++静态语言会直接编译链接成CPU能够直接执行的机器码，而是需要一个公共语言运行时(CLR)来进行及时的编译（JIT）。所以将其称为中间语言。JIT编译器的根据执行编译阶段大致可以分为3类： 1. Pre-JIT 编译器，在程序集部署时进行编译，就是通过一个Ngen.exe(本地代码生成器)将CIL转换为本地机器码。 2. Normal JIT 编译器，在程序集首次调用的时候将其编译成本地机器码并缓存。 3. Econo JIT 编译器，在方法执行前进行编译，执行完后删除，dotnet2.0后就使用的此类型的JIT 语言 CIL其实本身也是一门基于堆栈的编程语言，只是相比C#要稍微低级（并不是很low的意思）一些，我们也可以直接写CIL代码然后使用ILASM工具将其转换成程序集在CLR中运行。 我们在回头看看HelloWorld程序，里面调用了一个Console.WriteLine函数，那这个函数又是哪里来的呢？ BCL和FCL BCL-基础类库 我们在开发一个程序时，不可能任何基础功能都功能都从零开始，所以各个.Net的实现平台都为我们定义一个基础功能类库BCL, 比如像组数，链表，字典, Console,包括基本原类型byte，short, long这这些都是基于System下的System.Byte,System.Int16和System.Int64,当然还包含了先系统相关的功能比如线程,安全性等。但是各个平台的对这些接口的实现也有所差异，所以为了实现各个平台的通用性，微软在自家产品中率先制定了一个可移植类库PCL，取各个平台的公用部分形成，结构如下图： 随着实现.Net平台的增多，为了更好跨平台性微软制定了基础库的标准.Net Standard，所有.Net实现平台上的BCL接口都必须遵守.Net Standard中制定的标准，这样便可以让在各个平台开发时调用的基础库的接口都是统一的。虽然BCL构成了我们编程的基础库，但是比如我们要开发一个Windows的应用，那么界面该如何搭建呢，界面上又有哪些控件呢？接下来就要介绍框架类库-FCL了。FCL和.Net Standard关系图如下： FCL-框架类库 BCL只是框架类库的一个子集而已，FCL包含的功能巨多，也是我们经常使用的类库，每个FCL的子库都够写一本书的了，我们更具功能可以将FCL大致分为一下3层。 - 最内一层，由BCL的大部分组成，主要作用是对.NET框架，.NET运行时及CIL语言本身进行支持，例如基元类型、集合类型、线程处理、应用程序域、运行时、安全性、互操作等。 - 中间一层，包含了对操作系统功能的封装，例如文件系统、网络连接、图形图像、XML操作等。 - 最外一层，包含各种类型的应用程序，例如Windows Forms、Asp.NET、WPF等。 CTS-公共类型系统 如果我们要开发一门像C#或VB一样的语言，在编译后也生成CIL语言，在.Net环境中运行，那么我们这个语言具有哪些特性就不是我们语言所能决定的了，而是有CIL所定义的规则决定的，而这些定义的规则就是CTS,CTS中定义了类，接口，结构体也定义了类里能包含属性，字段，函数，事件等，也定义了类只能继承一个父类，可以实现多个接口。C#和VB就是微软定义的符合CTS规则的语言。 CLS-公共语言规范 假设我们有3门面向.Net的语言，如果3门语言公开（Public）部分需要相互调用,那么他们必定需要遵循一定规则，这个规则就是CLS,CLS是CTS的一个子集，各个面向.Net的语言需要准守这个规范，否则就不就会存在互调的兼容性问题。CLS具体有哪些规则呢？是否区分大小写，标识符的命名规则如何，可以使用的基本类型有哪些，构造函数的调用方式（是否会调用基类构造函数），支持的访问修饰符等。 CLR-公共语言运行时 前面我们了解了.Net SDK编译出来的程序集（Assembly）的相关信息，下面我们将接着讨论，编程出来的程序集是怎么运行起来的呢？这就的归功于CLR，CLR其实就是一个能够执行CIL的虚拟机，其主要功能包括：管理应用程序域、加载和运行程序集、安全检查、JIT(将CIL代码即时编译为机器代码)、异常处理、对象析构和垃圾回收等。现在我们了解了CLR的功能，但是还是不知道它是怎么运行起来的。要说清楚这个问题我们不必须先看看在系统中可执行文件的格式，在MacOs中是Mach-O格式，在Windows中是PE/COFF格式，在Linux是ELF格式，我们详细看下Mach-O文件吧，其他的格式都大同小异。Mach-O格式如下： Mach-O 的组成结构如图所示包括了： Header 包含该二进制文件的一般信息 字节顺序、架构类型、加载指令的数量等。 使得可以快速确认一些信息，比如当前文件用于 32 位还是 64 位，对应的处理器是什么、文件类型是什么 Load commands 一张包含很多内容的表 内容包括区域的位置、符号表、动态符号表等。 Data 通常是对象文件中最大的部分 包含 Segement 的具体数据 每个段的具体信息可以通过otool工具进行查看。\b 系统运行Mach-O文件大致步骤： 1. 系统把Mach-O文件加载进入内存， 2. 检查头看是否是相同CPU架构是否和符合当前的系统需求 3. 链接动态库 4. 找到入口程序(Main函数)的地址开始执行 我们发布一下HelloWorld程序，代码如下： 1dotnet publish -r osx-x64 -c Release --self-contained 我们通过自包含的方式发布，这样就不需要目标机器上安装.Net运行时了。我们来看一下发布后的文件有哪些,如下图： 重点是HelloWorld文件，这个文件是启动文件，这是一个Mach-O格式的文件，就想普通的MacOs系统的可以执行文件一样，他会链接像libclrjit.dylib,libcoreclr.dylib的CLR相关动态库文件，这样当HelloWorld通过系统调起的时候便会启动CLR, 并执行HelloWorld.dll中的主函数。我也可以直接使用dotnet HelloWorld.dll执行我们的程序集，因为dotnet这个Mach-o格式文件会去链接CLR相关的库。 总结 此篇文章主要讲了CLI规范中的相关术语，并通过一个HelloWorld的程序了解了一个CIL程序集时如何被编译生成的，也了解了一个程序集的内部结构，对.Net平台也有更深入的理解。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"}],"tags":[{"name":".Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"在Hexo中使用Mathjax渲染数学公式","slug":"工具/Hexo/在Hexo中渲染MathJax数学公式","date":"2021-03-03T14:33:17.591Z","updated":"2021-03-03T14:33:17.591Z","comments":true,"path":"2021/03/03/工具/Hexo/在Hexo中渲染MathJax数学公式/","link":"","permalink":"http://yoursite.com/2021/03/03/%E5%B7%A5%E5%85%B7/Hexo/%E5%9C%A8Hexo%E4%B8%AD%E6%B8%B2%E6%9F%93MathJax%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","excerpt":"前言 Mathjax是一种支持在所有浏览器上显示数学公式的Javascript引擎，它支持绝大部分的Tex/LaTex语法，并且有三种输出HTML/CSS, SVG(矢量图)和MathML（Firefox支持的数公式标记语言）。本文主要介绍如何在将Mathjax整合进入Hexo中，在整合之前先介绍一下Tex/LaTex。","text":"前言 Mathjax是一种支持在所有浏览器上显示数学公式的Javascript引擎，它支持绝大部分的Tex/LaTex语法，并且有三种输出HTML/CSS, SVG(矢量图)和MathML（Firefox支持的数公式标记语言）。本文主要介绍如何在将Mathjax整合进入Hexo中，在整合之前先介绍一下Tex/LaTex。 Tex/LaTex介绍 TeX是由著名的计算机科学家Donald E. Knuth（高德纳）发明的宏语言排版系统，由于Tex是一种程序式的排版系统，对于一般用户来说很难上手，此时LaTex就应运而生了。 LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。由于本文的目的是为了在网页上显示数学公式，对于LaTeX的其他文档的排版不做介绍。先来看看LaTex实例，如下： 1234$a=\\begin&#123;bmatrix&#125;1&amp;2&amp;3\\end&#123;bmatrix&#125;$ %行向量$a=\\begin&#123;bmatrix&#125;1\\\\2\\\\3\\end&#123;bmatrix&#125;$ %列向量$a\\cdot b=\\sum_&#123;i=1&#125;^&#123;n&#125;a_ib_i$ %累加和 对应的渲染效果，如下： a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\) a=\\(\\begin{bmatrix}1\\\\2\\\\3\\end{bmatrix}\\) \\(a\\cdot b=\\sum_{i=1}^{n}a_ib_i\\) Hexo配置Mathjax 在Hexo配置Mathjax只需要5个步骤： 步骤1：卸载默认的渲染引擎hexo-renderer-marked 1npm uninstall hexo-renderer-marked --save 步骤2：安装新的渲染引擎hexo-renderer-pandoc 1npm install hexo-renderer-pandoc --save 步骤3：安装新渲染引擎依赖的第三方工具pandoc 直接进入pandoc的官方网站下载，地址:https://pandoc.org/installing.html 每个系统的安装方式不一样，根据自己的系统进行安装。 步骤4：修改Hexo的主题配置 本人使用的是next主题，在./themes/next/_config.yml文件中修改，如下： 步骤5：在需要支持Mathjax文章的头部添加mathjax标记,如下图： LaTex常用数学表达式语法 直接参见：超详细 LaTex数学公式 参考文献 [1] 网页上显示数学公式目前哪种方案最好？ [2] LaTeX排版系统 [3] LaTeX快速入门：一文浅谈TeX排版语法 [4] Latex基础语法 [5] Latex官网 [6] 超详细 LaTex数学公式","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"工具/Hexo","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Mathjax","slug":"Mathjax","permalink":"http://yoursite.com/tags/Mathjax/"}]},{"title":"Mecanim动画系统","slug":"Unity/Unity3D_Mecanim高级动画系统","date":"2020-07-27T12:20:58.000Z","updated":"2021-03-21T09:53:32.069Z","comments":true,"path":"2020/07/27/Unity/Unity3D_Mecanim高级动画系统/","link":"","permalink":"http://yoursite.com/2020/07/27/Unity/Unity3D_Mecanim%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"介绍 资源制作 资源导入 Animator状态机 Animator混合树 Animator分层 Animator遮罩 Animator IK 运动重定向","categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"}]},{"title":"游戏介绍","slug":"游戏/游戏介绍","date":"2020-07-18T06:43:52.000Z","updated":"2021-03-03T14:33:17.602Z","comments":true,"path":"2020/07/18/游戏/游戏介绍/","link":"","permalink":"http://yoursite.com/2020/07/18/%E6%B8%B8%E6%88%8F/%E6%B8%B8%E6%88%8F%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"https://zhuanlan.zhihu.com/p/22745932 https://gameinstitute.qq.com/community/detail/101952","categories":[],"tags":[]},{"title":"安装CentOS 8","slug":"Linux/安装CentOS8","date":"2020-07-17T09:52:05.000Z","updated":"2021-03-03T14:33:17.590Z","comments":true,"path":"2020/07/17/Linux/安装CentOS8/","link":"","permalink":"http://yoursite.com/2020/07/17/Linux/%E5%AE%89%E8%A3%85CentOS8/","excerpt":"下载相关工具 下载CentOS8 系统镜像 官方下载地址：https://www.centos.org/download/，根据自己的情况选择下载什么镜像，阿里云和网易的镜像地址下载速度很快。本文下载的是CentOS-8.2.2004-x86_64最小化版，如果需要带GUI的系统可以下载完整版，各个版本的下载地址： 最小版本：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-minimal.iso 完整版：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-dvd1.iso","text":"下载相关工具 下载CentOS8 系统镜像 官方下载地址：https://www.centos.org/download/，根据自己的情况选择下载什么镜像，阿里云和网易的镜像地址下载速度很快。本文下载的是CentOS-8.2.2004-x86_64最小化版，如果需要带GUI的系统可以下载完整版，各个版本的下载地址： 最小版本：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-minimal.iso 完整版：http://mirrors.aliyun.com/centos/8.2.2004/isos/x86_64/CentOS-8.2.2004-x86_64-dvd1.iso 下载制作U盘启动盘工具 官方检测刻入U盘无问题工具：Win32diskimager。 注意：使用win32diskimager准备一个新的U盘，写入系统盘之后是无法再添加其它数据，当写入成功之后，再次插入发现U盘不能显示的，若需要恢复可以参考这里 制作U盘启动盘 当下载了CentOS8镜像和安装了Win32diskimager工具后，我们就可以开始制作启动盘了。以下是具体步骤： 启动Win32diskimager 选择\b刚下载的CentOS8的镜像文件，注意在打开的“文件选择对话框”的文件过滤下拉框中选择显示所有的文件，默认是显示.IMG的文件 选择写入的盘，注意不要选错了。 点击“写入”按钮，等待写入完成 安装系统 当系统盘写入完成后，就可以选择你的电脑进行安装了，具体步骤如下： 1. 进入BIOS设置，将你刚写入了系统的U盘设置为第一启动盘 等待启动选择安装（白色为选中）,如下图： 跟着后续的步骤进行安装即可 配置网络 参见另一篇文章 Linux网络配置","categories":[],"tags":[]},{"title":"游戏AI介绍","slug":"游戏/AI/游戏AI介绍","date":"2020-07-11T10:22:45.000Z","updated":"2021-03-09T15:19:52.367Z","comments":true,"path":"2020/07/11/游戏/AI/游戏AI介绍/","link":"","permalink":"http://yoursite.com/2020/07/11/%E6%B8%B8%E6%88%8F/AI/%E6%B8%B8%E6%88%8FAI%E4%BB%8B%E7%BB%8D/","excerpt":"什么是游戏AI AI（artificial intelligence）即人工智能，游戏中的AI是让游戏里的对象具有一定的智能化，能够思考和决策，比如RPG游戏中的怪物知道有玩家攻击自己时进行反击，当玩家逃跑时会进行追击，当玩家远离自己时则放弃追击，这一系的决策和动作就是游戏中的AI要做的。和现下流行的人工智能不一样的是游戏里的AI还不能那么智能，不过现在已经在尝试将机器学习和游戏结合，让游戏对象更智能。\b 自治智能体 正如其命，有自治动作的智能体称之为“自治智能体”。在《看门狗》《GTA》里，街上走路的人群或者开动的汽车 就是一种自治智能体。主角开车如果冲向它们，这些自治智能体能够自行判断并做出躲开的动作。 群体智能体 如其名，与自治智能体相对，“群体智能”一般用于编队的AI或者集群的AI。例如足球游戏里，AI操控一方所有球员互相配合传球踢球。又或者射击游戏里，AI操控一支小队通过战术进攻据点。","text":"什么是游戏AI AI（artificial intelligence）即人工智能，游戏中的AI是让游戏里的对象具有一定的智能化，能够思考和决策，比如RPG游戏中的怪物知道有玩家攻击自己时进行反击，当玩家逃跑时会进行追击，当玩家远离自己时则放弃追击，这一系的决策和动作就是游戏中的AI要做的。和现下流行的人工智能不一样的是游戏里的AI还不能那么智能，不过现在已经在尝试将机器学习和游戏结合，让游戏对象更智能。\b 自治智能体 正如其命，有自治动作的智能体称之为“自治智能体”。在《看门狗》《GTA》里，街上走路的人群或者开动的汽车 就是一种自治智能体。主角开车如果冲向它们，这些自治智能体能够自行判断并做出躲开的动作。 群体智能体 如其名，与自治智能体相对，“群体智能”一般用于编队的AI或者集群的AI。例如足球游戏里，AI操控一方所有球员互相配合传球踢球。又或者射击游戏里，AI操控一支小队通过战术进攻据点。 游戏AI相关的知识点 游戏中的对象想要智能必须要具备以下3点： 1. 对当前环境数据的搜集即感知， 比如当前自己所在的位置，血量以及前后左右有什么等； 2. 对当前环境的认识进行决策，比如检查自己的血量，比较少则逃跑，多则可以进行攻击； 3. 对决策执行相应的行为，比如使用技能，逃跑等； 感知相关知识点 \b为了让游戏里面的对象具有向人一样的智能，那么人所具有的感知系统：听觉、视觉和触觉都要在游戏进行模拟，才能让游戏里的智能对象具有类似人一样的的感知，当然在游戏里不能完全模拟人的的听觉、视觉和触觉，有的时候游戏里为了提高关卡难度也能让智能体感知到在真实世界里的人不能获取的感知，比如：能感知到自己背后的怪物，预知敌方的下一步行动，或者获得其他系统的相关信息。在这里就要引入一个叫做黑板概念，“黑板”简单来说就是可访问的共享数据，用于多模块间的数据共享。 听觉 视觉 触觉 黑板 决策相关知识点 行为相关知识点 参考文献 [1] 游戏AI研究（一）：感知AI [2] 游戏AI之初步介绍","categories":[],"tags":[]},{"title":"游戏寻路介绍","slug":"游戏/寻路算法/游戏寻路介绍","date":"2020-04-01T03:02:05.000Z","updated":"2021-03-03T14:33:17.600Z","comments":true,"path":"2020/04/01/游戏/寻路算法/游戏寻路介绍/","link":"","permalink":"http://yoursite.com/2020/04/01/%E6%B8%B8%E6%88%8F/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/%E6%B8%B8%E6%88%8F%E5%AF%BB%E8%B7%AF%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"","categories":[{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"寻路算法","slug":"游戏/寻路算法","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"矩阵","slug":"数学物理/矩阵","date":"2020-04-01T03:02:05.000Z","updated":"2021-03-03T14:33:17.592Z","comments":true,"path":"2020/04/01/数学物理/矩阵/","link":"","permalink":"http://yoursite.com/2020/04/01/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/%E7%9F%A9%E9%98%B5/","excerpt":"矩阵的基础定义 矩阵是3D数学的重要基础，它主要用来描述两个坐标系之间的关系，通过定义一种运算将一个坐标系中的向量转换到另一个坐标系中。 矩阵的数学定义 在线性代数中，矩阵就是以行和列形式组织的矩形数字块。例如下列的一个3x4的矩阵： \\[\\begin{bmatrix} 0&amp;-1&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;4 \\\\ 2&amp;1&amp;3&amp;-4 \\end{bmatrix}\\]","text":"矩阵的基础定义 矩阵是3D数学的重要基础，它主要用来描述两个坐标系之间的关系，通过定义一种运算将一个坐标系中的向量转换到另一个坐标系中。 矩阵的数学定义 在线性代数中，矩阵就是以行和列形式组织的矩形数字块。例如下列的一个3x4的矩阵： \\[\\begin{bmatrix} 0&amp;-1&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;4 \\\\ 2&amp;1&amp;3&amp;-4 \\end{bmatrix}\\] 方阵 行和列数相同的矩阵被定义为方阵，例如：2x2, 3x3, 4x4的矩阵都是方阵。方阵的对角线元素就是行号和列号都相同的元素。例如：3x3的矩阵M的对角线元素为\\(m_{11}\\), \\(m_{22}\\), \\(m_{33}\\)。其他元素为非对角线元素。 对角矩阵 非对角线元素都为0的元素为对角矩阵。 单位矩阵 单位矩阵是一种特殊的对角矩阵。它的对角元素都为1，非对角元素都为0. 单位矩阵非常特殊，因为它是矩阵的乘法单位元，其性质是用任意一个矩阵乘以单位矩阵，都将得到原矩阵。 矩阵运算 矩阵转置 一个r x c的矩阵M。M的转置记作\\(M^T\\), 是一个c x r的矩阵，它的列由M的行组成。可以从另一方面理解，\\(M_{ij}^T = M_{ji}\\) ,及沿着对角线翻折。例如： \\(\\begin{bmatrix} 0&amp;-1&amp;1&amp;1 \\\\ 1&amp;0&amp;1&amp;4 \\\\ 2&amp;1&amp;3&amp;-4 \\end{bmatrix}^T = \\begin{bmatrix} 0&amp;1&amp;2 \\\\ -1&amp;0&amp;1 \\\\ 1&amp;1&amp;3 \\\\ 1&amp;4&amp;-4 \\end{bmatrix}\\) 标量与矩阵乘法 \\(k\\textbf{M}=k\\begin{bmatrix} m_{11}&amp;m_{12}&amp;m_{13} \\\\ m_{21}&amp;m_{22}&amp;m_{23} \\\\ m_{31}&amp;m_{32}&amp;m_{33} \\end{bmatrix}= \\begin{bmatrix} km_{11}&amp;km_{12}&amp;km_{13} \\\\ km_{21}&amp;km_{22}&amp;km_{23} \\\\ km_{31}&amp;km_{32}&amp;km_{33} \\end{bmatrix}\\) 矩阵乘法 在某些情况下，两个矩阵可以相乘。决定矩阵能否相乘以及怎么计算结果的法则初看起来有些奇怪。一个r x n 矩阵A能够乘以一个n x c的矩阵B,结果是一个r x c的矩阵，记作 AB。矩阵乘法计算如下：记r x n矩阵A与n x c矩阵B的积r x c 矩阵AB为C。 C的任意元素\\(\\textbf{C}_{ij}\\)等于A的第i行向量与B的第j列向量的点乘结果。 正式定义为： \\(c_{ij} = \\sum_{k=1}^{n}a_{ik}b_{kj}\\) 矩阵乘法满足的定律（前提是矩阵乘法有意义）： 任意矩阵M乘以单位矩阵I的到原矩阵 MI=IM=M 矩阵乘法不满足交换律，即 AB \\(\\neq\\) BA 矩阵乘法满足结合律，即 (AB)C=A(BC) 矩阵的转置\\((AB)^T = B^TA^T\\) 向量与矩阵的乘法 因为向量能被当作是一个行或一列的矩阵，所以能够用上一节的矩阵乘法来计算。但是左乘矩阵和右乘矩阵这个两个的区别特别重要。例如，用矩阵A， B和C转换向量v,用行向量记法记作vABC。注意矩阵按顺序从左往右列出。如果使用列向量，矩阵放在左边，转换从右往左发生，这种情况下应该记作CBAv 矩阵的几何定义 一般来说，方阵能够描述任意线性变换，比如： 旋转 缩放 投影 镜像 仿射","categories":[{"name":"数学物理","slug":"数学物理","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[]},{"title":"向量","slug":"数学物理/向量","date":"2020-04-01T03:02:05.000Z","updated":"2021-03-03T14:33:17.591Z","comments":true,"path":"2020/04/01/数学物理/向量/","link":"","permalink":"http://yoursite.com/2020/04/01/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/%E5%90%91%E9%87%8F/","excerpt":"向量的基本定义 数学定义 向量就是一个数列，是一个只有大小和方向的一个数学量，和标量不同，标量是一个只有大小的量。向量的记法如下： 行向量:a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\) 列向量:a=\\(\\begin{bmatrix}1\\\\2\\\\3\\end{bmatrix}\\) 几何定义 向量是有大小和方向的有向线段。向量和点不同点表示了一个固定的位置然而向量是没有位置的，你画在任何地方都行，因为向量表示它在各个方向上的位移关系。向量的几何表示如下图：","text":"向量的基本定义 数学定义 向量就是一个数列，是一个只有大小和方向的一个数学量，和标量不同，标量是一个只有大小的量。向量的记法如下： 行向量:a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\) 列向量:a=\\(\\begin{bmatrix}1\\\\2\\\\3\\end{bmatrix}\\) 几何定义 向量是有大小和方向的有向线段。向量和点不同点表示了一个固定的位置然而向量是没有位置的，你画在任何地方都行，因为向量表示它在各个方向上的位移关系。向量的几何表示如下图： 向量的运算 负向量 负向量就是在一个向量的前面加上一个负号。例如：a=\\(\\begin{bmatrix}1&amp;2&amp;3\\end{bmatrix}\\),它的负向量就是\\(\\begin{bmatrix}-1&amp;-2&amp;-3\\end{bmatrix}\\) 运算法则 -\\(\\begin{bmatrix}a_1&amp;a_2&amp;\\cdots&amp;a_n\\end{bmatrix}\\)=\\(\\begin{bmatrix}-a_1&amp;-a_2&amp;\\cdots&amp;-a_n\\end{bmatrix}\\) 几何解释 向量变负，将得到一个和原向量大小相等，方向相反的向量。如下图： 标量与向量的乘法 向量与标量相乘，结果将得到一个与原向量平行，但长度不同或方向相反的向量。 运算法则 将向量中的每个元素和标量相乘。公式如下： \\[k\\begin{bmatrix}a_1\\\\ a_2\\\\ \\vdots\\\\a_n\\end{bmatrix}=\\begin{bmatrix}ka_1\\\\ ka_2\\\\ \\vdots\\\\ka_n\\end{bmatrix}\\] 几何解释 按照k的缩放因子进行缩放，如下： 向量的加法和减法 向量相加和相减的前提是两向量维度相同。结果向量的维度和原向量相同。 运算法则 将对应的向量元素相加。公式如下： \\[\\begin{bmatrix}a_1\\\\ a_2\\\\ \\vdots\\\\a_n\\end{bmatrix}+\\begin{bmatrix}b_1\\\\ b_2\\\\ \\vdots\\\\b_n\\end{bmatrix}=\\begin{bmatrix}a_1+b_1\\\\ a_2 + b_2\\\\ \\vdots\\\\a_n+b_n\\end{bmatrix}\\] 减法的操作可以转换为加法：a-b=a+(-b) 几何解释 向量点乘(内积) 运算法则 向量点乘就是对应分量乘积的和，其结果是一个标量： \\[\\begin{bmatrix}a_1\\\\ a_2\\\\ \\vdots\\\\a_n\\end{bmatrix}\\cdot\\begin{bmatrix}b_1\\\\ b_2\\\\ \\vdots\\\\b_n\\end{bmatrix}=a_1b_1+a_2b_2+\\cdots+a_nb_n\\] 用连加符号简写为： \\(a\\cdot b=\\sum_{i=1}^{n}a_ib_i\\) 几何解释 一般来说，点乘结果描述了两个向量的“相似”程度，点乘结果越大，两向量越相近。如下图： 点乘等于向量大小与向量夹角的\\(cos\\)值的积： \\(a\\cdot b=||a|| ||b||cos{\\theta}\\) 向量叉乘(叉积) 运算法则 向量叉乘得到一个向量且不满足交换律，点乘满足交换律。公式如下： \\[\\begin{bmatrix}x_1\\\\y_1\\\\z_1\\end{bmatrix}\\times\\begin{bmatrix}x_2\\\\y_2\\\\z_2\\end{bmatrix} =\\begin{bmatrix}y_1z_2 -z_1y_2\\\\z_1x_2-x_1z_2\\\\x_1y_2-y_1x_2\\end{bmatrix}\\] 几何解释 （1）.叉乘得到的向量垂直于原来的两个向量，如下图： 这里写图片描述 \\(a\\times b\\)的长度等于向量的大小与向量的夹角\\(sin\\)值的积，如下： \\[||a\\times b||=||a||||b||sin{\\theta}\\] 已经证明了\\(a\\times b\\)垂直于a,b。但是垂直于a,b有两个方向。\\(a\\times b\\)指向哪个方向呢？通过将a的头与b的尾相连，并检测从a到b是顺时针还是逆时针。如果在左手坐标系中，左手四个（除大拇指）指母重贴与a,b向量的方向大拇指指向的方向就是\\(a\\times b\\)垂直的方向。右手坐标的也相同只是使用右手来判断。 （2）.\\(||a\\times b||\\)也等于两向量组成的平行四边形的面积。 向量大小(长度或模) 运算法则 公式如下： \\[||v||=\\sqrt{v_1^2+v_2^2+\\cdots+v_n^2}\\] 或 \\[||v||=\\sqrt{\\sum_{i=1}^{n} v_i^2}\\] 距离公式 同一坐标系中的两个点的距离，实际上可以看作是两个点构成的一个向量，那么两个点的距离就等于此向量的模长。 运算法则 距离\\(（a,b）=||b-a||=\\sqrt{(b_x-a_x)^2+(b_y-a_y)^2+(b_z-a_z)^2}\\) 标准化向量 对于许多向量，我们只关心它的方向而不是大小。在这种情况下使用单位向量将会非常方便。单位向量就是大小为1的向量，单位向量也被称之为标准向量或更简洁地称为法线。 运算法则 对于任意非零向量v，都能计算出一个和v方向相同的单位向量\\(v_{norm}\\)。这个过程被称作向量的标准化，要标准化向量，将向量除以他的大小（模）即可。公式如下： \\[v_{norm}=\\frac{v}{||v||},v\\ne 0\\] 注意：零向量是不能被标准化的，因为除零是没有定义的。 几何解释 如下图： 向量投影 给定两个向量v和n，能将v分解成两个分量：\\(v_{||}和v_{\\perp}\\)。他们分别平行和垂直于n，并满足\\(v=v_{||}+v_{\\perp}\\)。一般称平行分量\\(v_{||}\\)为v在n上的投影。 运算法则 公式如下： \\[v_{||}=n\\frac{v\\cdot n}{||n||^2}\\] \\[v_{\\perp}=v-v_{||}\\] 几何解释 如下图： 总结 向量是用来表示方位和距离的，也就是映射到每个轴的偏移。向量的常规运算有：向量与标量乘法，向量加减法，向量点乘，向量叉乘。 参考文献 [1] Fletcher Dunnlan Parberry. 3D数学基础：图形与游戏开发.北京:清华大学出版社.2005.1.","categories":[{"name":"数学物理","slug":"数学物理","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[]},{"title":"CentOS安装Docker","slug":"服务器/Docker/CentOS安装Docker","date":"2020-03-10T03:02:33.000Z","updated":"2021-03-03T14:33:17.593Z","comments":true,"path":"2020/03/10/服务器/Docker/CentOS安装Docker/","link":"","permalink":"http://yoursite.com/2020/03/10/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/CentOS%E5%AE%89%E8%A3%85Docker/","excerpt":"OS需求 CentOS 7 centos-extra必须启用，默认是启用的 卸载老的版本（如果有安装过的） 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 在/var/lib/docker目录中的镜像，容器和网络被保留了，如果不需要也可以将其移除掉","text":"OS需求 CentOS 7 centos-extra必须启用，默认是启用的 卸载老的版本（如果有安装过的） 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 在/var/lib/docker目录中的镜像，容器和网络被保留了，如果不需要也可以将其移除掉 安装Docker Engine社区版 Docker官方提供了3中安装方式，如下： - 大多数用户采用设置Docker仓库的方式进行安装，这也是简单的安装和更新的方式，本文也只将介绍此安装方法，其他的安装方式，参考官方文档 - 下载RPM包进行安装并且手动的安装和管理更新，这种方式适合在没有没有网的环境下安装 - 在装测试和开发环境，有的用户选择使用自动化脚本安装，生成环境不推荐 设置Docker仓库 在一个新系统安装时，首先需要设置一个Docker仓库，如果已经添加过仓库，可以跳过这步。 1. 安装需要的包：yum-utils ，此包提供了yum-config-manager工具；以及device-mapper-persistent-data 和 lvm2 （devicemapper存储驱动需要它们） 123sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用下面的命令设置一个稳定版的Docker仓库 123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装 安装最新版 使用下面的命令安装最新版Docker引擎，如下： 1sudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose 安装指定版本 安装指定版本的的Docker引擎 1. 先列出有哪些版本可以安装，命令如下： 123456yum list docker-ce --showduplicates | sort -r--命令列出的结果docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 安装指定版本，命令如下： 1sudo yum install -y docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 启动Docker-CE引擎 命令如下： 1sudo systemctl start docker 验证Docker-CE是否安装成功 命令如下： 1sudo docker run hello-world 登录DockerHub 1docker login 卸载Docker-CE 卸载包 1sudo yum remove docker-ce 删除镜像，容器，卷以及自定义的配置 1sudo rm -rf /var/lib/docker","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Docker","slug":"服务器/Docker","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/"}],"tags":[{"name":"Dokcer","slug":"Dokcer","permalink":"http://yoursite.com/tags/Dokcer/"}]},{"title":"Redis安装与配置","slug":"服务器/服务软件/Redis安装与配置","date":"2020-01-15T09:15:18.000Z","updated":"2021-03-03T14:33:17.594Z","comments":true,"path":"2020/01/15/服务器/服务软件/Redis安装与配置/","link":"","permalink":"http://yoursite.com/2020/01/15/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"安装 yum 安装 12yum info redis // 查看当前源的redis最新版本信息yum install redis","text":"安装 yum 安装 12yum info redis // 查看当前源的redis最新版本信息yum install redis 源码安装 1234567# 下载地址从[官网](https://redis.io/download)获取最新的wget http://download.redis.io/releases/redis-3.2.10.tar.gztar -zxvf redis-3.2.10.tar.gzcd redis-3.2.10makemake install 注意：如果没有c编译环境记得安装，如下： 1yum -y install gcc gcc-c++ kernel-devel //安装gcc、c++编译器以及内核文件 注意：如果没有jemalloc库，在make的时候添加如下参数： 1make MALLOC=libc 安装成功后，查看redis-server的位置。 1whereis redis-server 配置 配置文件需要启动后才会生成，如何启动参见“启动”章节， 不同的安装方式配置文件放的位置不太一样， yun安装：/etc/redis.conf 源码安装,需要收到将配置文件拷贝到/etc目录： 12cd /xxx/redis-3.2.10cp redis.conf /etc/ 基础配置 123456# 端口配置port 6379# 让redis后台运行，默认是nodaemonize yes# 日志文件配置logfile \"/var/log/redis.log\" 持久化配置 快照RDB持久化配置 123456789101112131415161718# Save the DB on disk:# 设置sedis进行数据库镜像的频率。# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）。# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）。# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）。save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yes# 在进行镜像备份时,是否进行压缩。yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间。rdbcompression yes# 一个CRC64的校验就被放在了文件末尾，当存储或者加载rbd文件的时候会有一个10%左右的性能下降，为了达到性能的最大化，你可以关掉这个配置项。rdbchecksum yes# 快照的文件名dbfilename dump.rdb# 存放快照的目录dir /var/lib/redis AOF持久化配置 12345678910111213141516# 是否开启AOF，默认关闭（no）appendonly yes# 指定 AOF 文件名appendfilename appendonly.aof# Redis支持三种不同的刷写模式：# appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。# appendfsync no #完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。#在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO上的冲突。#设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yesno-appendfsync-on-rewrite yes #当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。auto-aof-rewrite-percentage 100#当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。auto-aof-rewrite-min-size 64mb 两种持久化的区别 1）如果能接受几分钟的数据丢失的话，建议选择快照RDB 2）要是不允许数据丢失，则需要用AOF来持久化 关于数据恢复： RDB的启动时间会更短，原因有两个： 一是RDB文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了。 另一个原因是RDB文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作，所以在CPU消耗上要远小于AOF日志的加载。 注意： AOF(Append Only File)比RDB方式有更好的持久化性。由于在使用AOF持久化方式时，Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。 AOF的完全持久化方式同时也带来了另一个问题，持久化文件会变得越来越大。(比如我们调用INCR test命令100次，文件中就必须保存全部的100条命令，但其实99条都是多余的。因为要恢复数据库的状态其实文件中保存一条SET test 100就够了)。为了合并重写AOF的持久化文件，Redis提供了bgrewriteaof命令。 Redis重启如何载入数据的 通过日志可以很清楚的知道redis通过那个文件来取数据的： RDB: * DB loaded from disk: 0.000 seconds AOF: * DB loaded from append only file: 0.000 seconds 保存数据则是： RDB: * DB saved on disk AOF: * Calling fsync() on the AOF file. 重启时将按照以下优先级恢复数据到内存 如果只配置AOF,重启时加载AOF文件恢复数据。 如果同时 配置了RBD和AOF,启动是只加载AOF文件恢复数据。 如果只配置RBD,启动是讲加载dump文件恢复数据。 如果你先开启了RDB模式，想再开启AOF模式，先执行bgrewriteaof命令，不然会因为恢复数据的优先级问题，数据都没有了。 为了防止悲剧发生，注意多备份，AOF模式，记得使用脚本定期执行bgrewriteaof命令。 脚本如下，可以结合Linux Crontab来使用，定期执行。 12echo 'bgrewriteaof redis 6379'redis-cli -p 6379 bgrewriteaof 启动 普通启动 首次启动，命令如下： 1redis-server 首次启动会生成默认配置文件redis.conf 配置文件生成后，后面每次启动就可以直接跟上配置文件了，如下： 1redis-server /etc/redis.conf ## 开机自启动 在/etc/rc.d/rc.local文件尾部添加一行，如下： 1redis-server /etc/redis.conf 检查一下rc.local有没有执行权限，如果没有加上执行权限，如下： 1chmod +x /etc/rc.d/rc.local 如果未执行成功,查看logfile.log日志,寻找原因。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Git服务器搭建","slug":"服务器/服务软件/Git服务器搭建","date":"2019-12-27T07:08:26.000Z","updated":"2021-03-03T14:33:17.593Z","comments":true,"path":"2019/12/27/服务器/服务软件/Git服务器搭建/","link":"","permalink":"http://yoursite.com/2019/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","excerpt":"CentOS安装与配置Git","text":"CentOS安装与配置Git 使用yum命令安装： 1yum install -y git 为Git单独创建一个用户 创建用户 1adduser git 修改密码 1passwd git 创建Git仓库 创建一个目录存放Git仓库，目录/data/git 12mkdir /data/gitgit init --bare Puzzle.git 将Puzzle.git的拥有者修改为上面创建的git用户 1chown git:git Puzzle.git 开启ssh key登录 编辑/etc/ssh/sshd_config文件,把下下面三个的注释打开，如果没有自行新建 123RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 禁用git用户的shell登陆 编辑/etc/passwd文件，找到git用户对应的配置，将最后一个分号的内容修改成/usr/bin/git-shell,如下： 12git:x:1000:1001::/home/git:/bin/bash #改成如下，git:x:1000:1001::/home/git:/usr/bin/git-shell 输入git用户的密码进行验证，至此已完成在服务器配置Git仓库的任务，但是这样每次更新都会要求输入密码，特麻烦，下面章节将介绍更安全便捷的访问方式。 客户端配置 Windows配置 Git的客户端选择使用TortoiseGit。 下载TortoiseGit，下载地址如下： https://tortoisegit.org/download/ 安装TortoiseGit，就跟安装普通应用程序一样，下一步-&gt;下一步 生成Putty Key, 成功安装TortoiseGit后在其安装目录下的bin目录下会有一个PuttyGen的应用程序用于生成Putty key 启动PuttyGen生成并保存key,如下图： 生成KEY 保存KEY 拷贝公匙到服务器的/home/git/.ssh/authorized_keys文件末尾，注意如果没有相应文件夹或文件请自行创建,注意权限参见“遇到的问题”章节 使用TortoiseGit下载Git仓库 在一个空目录邮件单机，选择Git Clone...,如下图： Mac/Linux配置 将~/.ssh目录下的id_rsa.pub内容追加到到服务器的/home/git/.ssh/authorized_keys文件末尾。如果没有id_rsa.pub, 可以用ssh-keygen来创建 在其他电脑上测试能否克隆远程仓库 1git clone ssh://git@192.168.0.172:22/data/git/Puzzle.git 遇到的问题 在对应用户（git）目录下.ssh的目录权限必须是700， authorized_keys文件必须是600的权限","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]},{"title":"Nginx安装与配置","slug":"服务器/服务软件/nginx安装与配置","date":"2019-12-08T16:00:00.000Z","updated":"2021-06-15T10:13:45.426Z","comments":true,"path":"2019/12/09/服务器/服务软件/nginx安装与配置/","link":"","permalink":"http://yoursite.com/2019/12/09/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"简介 Nginx是个web，反向代理, 负载均衡, 邮件代理和HTTP缓存服务器.","text":"简介 Nginx是个web，反向代理, 负载均衡, 邮件代理和HTTP缓存服务器. 安装 centos安装 1.安装准备 sudo yum install yum-utils 2.设置yum仓库，使用下面的内容创建一个/etc/yum.repos.d/nginx.repo文件 [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 3.安装Nginx sudo yum install nginx 配置 通常Nginx的配置放在下面几目录中： - /etc/nginx/nginx.conf , - /usr/local/etc/nginx/nginx.conf 或 - /usr/local/nginx/conf/nginx.conf 先看看默认的配置文件，如下： 1234567891011121314151617181920212223242526272829user nginx; #用户worker_processes 1; #工作进程数量error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn; #错误日志pid &#x2F;var&#x2F;run&#x2F;nginx.pid; #定义一个存储主进程ID文件events &#123; worker_connections 1024; #最大同时连接数&#125;http &#123; include &#x2F;etc&#x2F;nginx&#x2F;mime.types; #扩展名对应的MIME类型 default_type application&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; #访问日志文件 sendfile on; #非阻塞磁盘IO #tcp_nopush on; keepalive_timeout 65; #连接超时值 #gzip on; include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf; #包含其他配置文件,在这目录下有一个default.conf文件，里面配置了服务器上下文&#125; 配置文件由上下文（模块）与指令两部组成的树形结构指令集，子上下文的指令会覆盖父上下的指令。Nginx的核心上下文有： - 主上下文或全局上下文 - events上下文 - http上下文 - server上下文 - location上下文 其他上下文参见官网文档 ## 配置 ### 核心上下文 #### 主上下文 12345# 最外层的上下文，者是主上下文. . .context &#123; . . .&#125; Events上下文 123456# main contextevents &#123; # events context . . .&#125; HTTP上下文 1234567891011# main context. . .events &#123; # events context . . .&#125;http &#123; # http context . . .&#125; Server上下文 1234567891011121314# main contexthttp &#123; # http context server &#123; # first server context &#125; server &#123; # second server context &#125;&#125; Location上下文 1234567891011121314151617181920212223242526# main contextserver &#123; # server context #location [modifier] path # = - 精准匹配 # ^~ - 优先匹配 # ~ &amp;&amp; ~* - 正则匹配 # no modifier - 前缀匹配 location /match/criteria &#123;s # first location context &#125; location /other/criteria &#123; # second location context location nested_match &#123; # first nested location &#125; location other_nested &#123; # second nested location &#125; &#125;&#125; 核心配置指令 1234567891011121314151617181920212223242526272829303132# 指定用户user www www;# 指定工作进程数量或者自动（根据cpu等相关信息自动选择）worker_processes 2|auto;# 指定日志文件error_log /var/log/nginx-error.log info;# 访问日志文件（http, server, location, if in location, limit_except）access_log /var/log/nginx-access.log;# 监听指令并为默认服务器listen *:80 default_server;# 服务器名字(域名)server_name qilezaitu.top# 指定根目录指令root /var/www/qilezaitu;# 指定首页文件index index.html index.htm index.php;# try_files指令，在try_files列表你查找文件 ，其中$uri就是用户请求的uritry_files $uri index.html =404;# 包含指令,包含其他配置或文件include /etc/nginx/conf.d/*.conf;# 返回指令return 200 \"Hello from netguru.co\"; 优化配置指令 1234567#开启各类优化配置tcp_nodelay ontcp_nopush onsendfile onkeepalive_timeout 65;worker_connections 4096;worker_rlimit_nofile 8192; 常用服务器配置 此节将简单的配置一下几种服务器，Web服务器,负载均衡服务器和代理服务器。 在/etc/nginx/nginx.conf文件中进行配置，如下： 12345678910111213141516171819202122232425262728293031323334user nginx; worker_processes auto;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;worker_rlimit_nofile 8192;events &#123; worker_connections 4096;&#125;http &#123; include /etc/nginx/mime.types; index index.html index.htm index.php; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; keepalive_timeout 65; server_names_hash_bucket_size 128; # 包含conf.d目录下的所有配置，后续的服务器配置都将在这个目录进行 include /etc/nginx/conf.d/*.conf;&#125; 最后将/etc/nginx/conf.d/的默认配置文件备份，下面将在此目录下配置不同的服务器。 Web服务器配置 在/etc/nginx/conf.d/目录下新建一个配置文件命名为home.qilezaitu.top.conf 内容如下： 12345678910server &#123; listen *:80; server_name home.qilezaitu.top www.home.qilezaitu.top; access_log /var/log/nginx/access.log main; root /usr/share/nginx/html/blog; location / &#123; &#125;&#125; 负载均衡服务器配置 在/etc/nginx/conf.d/目录下新建一个配置文件命名为balance.conf 内容如下： 12345678910111213141516upstream big_server_com &#123; server 127.0.0.3:8000 weight=5; server 127.0.0.3:8001 weight=5; server 192.168.0.1:8000; server 192.168.0.1:8001; &#125; server &#123; # simple load balancing listen 80; server_name big.server.com; access_log logs/big.server.access.log main; location / &#123; proxy_pass http://big_server_com; &#125; &#125; 代理服务器配置 在/etc/nginx/conf.d/目录下新建一个配置文件命名为proxy.conf 内容如下： 123456789101112131415161718192021222324252627proxy_redirect off;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;client_max_body_size 10m;client_body_buffer_size 128k;proxy_connect_timeout 90;proxy_send_timeout 90;proxy_read_timeout 90;proxy_buffers 32 4k;server &#123; # simple reverse-proxy listen 80; server_name domain2.com www.domain2.com; access_log logs/domain2.access.log main; # serve static files location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; root /var/www/virtual/big.server.com/htdocs; expires 30d; &#125; # pass requests for dynamic content to rails/turbogears/zope, et al location / &#123; proxy_pass http://127.0.0.1:8080; &#125; &#125; SSL/STL配置 123456789101112131415server &#123; listen 443 ssl; server_name qilezaitu.top www.qilezaitu.top; root /var/www/html; index index.html index.htm; ssl_certificate /etc/nginx/ssl/qilezaitu.top.pem; ssl_certificate_key /etc/nginx/ssl/qilezaitu.top.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; location / &#123; &#125;&#125; 强制http到https 12345server &#123; listen 80; server_name qilezaitu.top; rewrite ^(.*)$ https://qilezaitu.top permanent;&#125; 启动 启动Nginx只需要简单的输入 1nginx 当启动了nginx启动后，可以通过发送信号的方式管理你的nginx,如下： 1nginx -s signal 可用的signal： - stop:快速关闭 - quit:等待工作进程完成了当前的请求后关闭 - reload:重载配置 - reopen:刷新日志文件 将Nginx加入到自启动，在/etc/rc.d/rc.local文件中追加一行，如下： 1nginx 记录各种问题 总结 参考 Apache Vs NGINX – Which Is The Best Web Server for You? Nginx安装教程 Nginx Tutorial #1: Basic Concepts Understanding the Nginx Configuration File Structure and Configuration Contexts Alphabetical index of directives nginx.conf","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[]}],"categories":[{"name":"Unity","slug":"Unity","permalink":"http://yoursite.com/categories/Unity/"},{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C#","slug":"编程语言/C","permalink":"http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Hexo","slug":"工具/Hexo","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Hexo/"},{"name":"游戏","slug":"游戏","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/"},{"name":"寻路算法","slug":"游戏/寻路算法","permalink":"http://yoursite.com/categories/%E6%B8%B8%E6%88%8F/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"},{"name":"数学物理","slug":"数学物理","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Docker","slug":"服务器/Docker","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/Docker/"},{"name":"服务软件","slug":"服务器/服务软件","permalink":"http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E8%BD%AF%E4%BB%B6/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"协程","slug":"协程","permalink":"http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"C#","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":".Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Mathjax","slug":"Mathjax","permalink":"http://yoursite.com/tags/Mathjax/"},{"name":"Dokcer","slug":"Dokcer","permalink":"http://yoursite.com/tags/Dokcer/"}]}